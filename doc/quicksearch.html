<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Map.js.html":{"id":"Map.js.html","title":"Source: Map.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Map.js var PigeonGLConstants = require(&quot;./constants.js&quot;); var CameraControl = require(&quot;./Camera/CameraControl.js&quot;); var utils = require(&quot;./Utils/Utils.js&quot;); var Layer = require(&quot;./Layers/Layer.js&quot;); /** * 信鸽地图地图核心类，用于生成3d空间地图底层 */ class Map extends Layer{ _layerid=0; zIndex=1000; status=&quot;running&quot;; /** * 地图构造函数 * @constructor * @param {Object} map - 地图绘制对象,目前支持高德,mapbox或者纯空间 * @param {Number} map.width - 地图宽度, default:1000 * @param {Number} map.height - 地图高度, default:600 * @param {Number} map.rotation - 地图旋转角度, default:60 * @param {Number} map.pitch - 地图俯视角度, default:45 * @param {Array} map.center - 地图默认中心位置经纬度, default:[0,0] * @param {Number} map.zoom - 地图缩放级别,default:21 */ constructor(map){ super(); this.clock = new THREE.Clock(); this.clock.start(); this.initMap(map); this.initWorld(); if(this.map.hasGround){ this.addGround() } this.update(); }; initWorld(){ // Set up a THREE.js scene this.renderer = new THREE.WebGLRenderer( Object.assign({ alpha: true, antialias:true},this.map.rendererOptions )); this.renderer.setSize( this.map.width, this.map.height ); this.renderer.shadowMap.enabled = true; this.map.container.appendChild( this.renderer.domElement ); this.renderer.domElement.style[&quot;position&quot;] = &quot;relative&quot;; this.renderer.domElement.style[&quot;pointer-events&quot;] = &quot;none&quot;; this.renderer.domElement.style[&quot;z-index&quot;] = ++this.zIndex; //this.renderer.domElement.style[&quot;transform&quot;] = &quot;scale(1,-1)&quot;; var _this = this; /** * @property {Object} scene - this.scene为three.js场景 */ this.scene = new THREE.Scene(Object.assign({ }, this.map.sceneOptions||{})); /** * @property {Object} camera - this.camera.js场景 */ this.camera = new THREE.PerspectiveCamera( 28, this.map.width / this.map.height, 0.000001, 5000000000); /** * @property {Object} layers - 图层集合 */ this.layers = []; // The CameraSync object will keep the Mapbox and THREE.js camera movements in sync. // It requires a world group to scale as we zoom in. Rotation is handled in the camera's // projection matrix itself (as is field of view and near/far clipping) // It automatically registers to listen for move events on the map so we don't need to do that here /** * @property {Object} world - this.world为世界模型组，所有模型被添加到该组内 */ this.world = new THREE.Group(); this.scene.add(this.world); /** * @property {CameraControl} cameraControl - 摄像机控制类 */ this.cameraControl = new CameraControl(this.map, this.camera, this.world); } initMap(map){ //mapbox if(map.transform){ this.map = map; this.map.MAP_TYPE = 'mapbox'; this.map.width = this.map.transform.width; this.map.height = this.map.transform.height; this.map.container = this.map._container; this.map.on(&quot;resize&quot;, function() { _this.renderer.setSize(_this.map.width, _this.map.height); } ); }else if(map.poiOnAMAP){//amap this.map = map; this.map.MAP_TYPE = 'amap'; this.map.container = this.map.getContainer(); this.map.width = this.map.container.clientWidth; this.map.height = this.map.container.clientHeight; this.map.on(&quot;resize&quot;, function() { _this.renderer.setSize(_this.map.width, _this.map.height); } ); }else{ /** * @property {Object} map - map对象，包含map的位置信息等，如果是高德或mapbox则为地图对象 * 默认值为 * rotation:0, width:1000, height:600, pitch:45, zoom:21, center:[0,0] */ this.map = Object.assign({ rotation:0, width:1000, height:600, pitch:45, zoom:21, center:[0,0] },map); this.map.MAP_TYPE = 'none'; } } /** * 自动刷新渲染，可以改变this.status=='top',停止自动刷新 * @parma {Number} delta - 每帧时间差，用来保持不同机器动画速度相同,用不到不必搭理 */ update(delta) { // Update any animations //this.animationManager.update(timestamp); var delta = this.clock.getDelta(); //子layer更新 for(var x in this.layers){ if(this.layers[x].update){ this.layers[x].update(delta) } } // Render the scene this.renderer.render( this.scene, this.camera ); // Run this again next frame var thisthis = this; requestAnimationFrame(function(timestamp) { if(thisthis.status!='stop')thisthis.update(delta); } ); } /** * 添加图层 * @param {Layer} layer - 图层 */ addLayer(layer){ layer.id = ++this._layerid; this.layers.push(layer); layer.onAdd(this);//初始化layer } /** * 删除图层 * @param {Layer} layer - 图层 */ removeLayer(layer){ for(var x in this.layers){ if(this.layers[x].id==layer.id){ this.layers[x].onRemove(); this.layers.splice(x,1); return; } } } /** * 投影到3d坐标系 * @param {Array} coords - 经纬度 [lng,lat],经度在前，纬度在后 * @return {Object} Vecotor3 - */ projectToWorld(coords){ // Spherical mercator forward projection, re-scaling to WORLD_SIZE var projected = [ -PigeonGLConstants.MERCATOR_A * coords[0] * PigeonGLConstants.DEG2RAD * PigeonGLConstants.PROJECTION_WORLD_SIZE, -PigeonGLConstants.MERCATOR_A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * coords[1] * PigeonGLConstants.DEG2RAD))) * PigeonGLConstants.PROJECTION_WORLD_SIZE ]; var pixelsPerMeter = this.projectedUnitsPerMeter(coords[1]); //z dimension var height = coords[2] || 0; projected.push( height * pixelsPerMeter ); var result = new THREE.Vector3(projected[0], projected[1], projected[2]); return result; } /** * 获取该维度的1m缩放比例 * @param {Number} latitude - 纬度 */ projectedUnitsPerMeter(latitude) { return Math.abs(PigeonGLConstants.WORLD_SIZE * (1 / Math.cos(latitude*Math.PI/180))/PigeonGLConstants.EARTH_CIRCUMFERENCE); } _scaleVerticesToMeters(centerLatLng, vertices) { var pixelsPerMeter = this.projectedUnitsPerMeter(centerLatLng[1]); var centerProjected = this.projectToWorld(centerLatLng); for (var i = 0; i &lt; vertices.length; i++) { vertices[i].multiplyScalar(pixelsPerMeter); } return vertices; } /** * 经纬度转换屏幕坐标 * @param {Array} coords - 经纬度 [lng,lat] * @return {Object} position - 返回距离容器左上角的距离 {x,y} */ projectToScreen(coords) { coords[1] = -coords[1]; var world = this.projectToWorld(coords); var scale = this.map.transform.scale; world.multiplyScalar(scale);//此处乘底盘被放大的倍数，否则屏幕坐标是放大前的 var standarVector = world.project(this.camera);//世界坐标转设备坐标 var a = this.map.width / 2; var b = this.map.height / 2; var x = Math.round(standarVector.x * a + a);//标准设备坐标转屏幕坐标 var y = Math.round(standarVector.y * b + b);//标准设备坐标转屏幕坐标 return { x:x, y:y } } /** * 屏幕坐标转转经纬度 * @param {Object} pixel - 屏幕坐标 {x,y} * @return {Array} lnglat - [lng,lat] */ unprojectFromScreen(pixel) { var a = this.map.width / 2; var b = this.map.height / 2; var standX = -(pixel.x - a)/a; var standY = (pixel.y - b)/b; var standarVector = new THREE.Vector3(standX,standY,0); var world = standarVector.unproject(this.camera); var scale = this.map.transform.scale;//除以放大的倍数，得到真实的world内坐标 standarVector.multiplyScalar(1/scale); var lnglat = this.unprojectFromWorld(world) lnglat[1] = - lnglat[1]; return lnglat; } /** * 世界坐标转经纬度 * @param {Object} xyz - 世界坐标 {x,y,z} * @return {Array} lnglat - [lng,lat] */ unprojectFromWorld(pixel) { var unprojected = [ -pixel.x / (PigeonGLConstants.MERCATOR_A * PigeonGLConstants.DEG2RAD * PigeonGLConstants.PROJECTION_WORLD_SIZE), 2*(Math.atan(Math.exp(pixel.y/(PigeonGLConstants.PROJECTION_WORLD_SIZE*(-PigeonGLConstants.MERCATOR_A))))-Math.PI/4)/PigeonGLConstants.DEG2RAD ]; var pixelsPerMeter = this.projectedUnitsPerMeter(unprojected[1]); //z dimension var height = pixel.z || 0; unprojected.push( height / pixelsPerMeter ); return unprojected; } _flipMaterialSides(obj) { } /** * 添加物体到3d空间 * @param {Object} obj - Three.js的mesh * @param {lnglat} Array - 物体的经纬度 {lng,lat} * @param {Object} options - 配置 * @param {Boolean} options.scaleToLatitude - 是否按照1px = 1m的比例进行缩放 默认true * @param {Number} options.preScale - 改变像素到米的换算比例 默认1 * @return {Object} obj -物体mesh */ addAtCoordinate(obj, lnglat, options) { var geoGroup = new THREE.Group(); geoGroup.userData.isGeoGroup = true; geoGroup.add(obj); this._flipMaterialSides(obj); this.world.add(geoGroup); this.moveToCoordinate(obj, lnglat, options); // Bestow this mesh with animation superpowers and keeps track of its movements in the global animation queue //this.animationManager.enroll(obj); return obj; } /** * 移动3d空间的物体 * @param {Object} obj - Three.js的mesh * @param {lnglat} Array - 物体的经纬度 {lng,lat} * @param {Object} options - 配置 * @param {Boolean} options.scaleToLatitude - 是否按照1px = 1m的比例进行缩放 默认true * @param {Number} options.preScale - 改变像素到米的换算比例 默认1 * @return {Object} obj - 物体mesh */ moveToCoordinate(obj, lnglat, options) { /** Place the given object on the map, centered around the provided longitude and latitude The object's internal coordinates are assumed to be in meter-offset format, meaning 1 unit represents 1 meter distance away from the provided coordinate. */ if (options === undefined) options = {}; if(options.preScale === undefined) options.preScale = 1.0; if(options.scaleToLatitude === undefined || obj.userData.scaleToLatitude) options.scaleToLatitude = true; obj.userData.scaleToLatitude = options.scaleToLatitude; if (typeof options.preScale === 'number') options.preScale = new THREE.Vector3(options.preScale, options.preScale, options.preScale); else if(options.preScale.constructor === Array &amp;&amp; options.preScale.length === 3) options.preScale = new THREE.Vector3(options.preScale[0], options.preScale[1], options.preScale[2]); else if(options.preScale.constructor !== THREE.Vector3) { console.warn(&quot;Invalid preScale value: number, Array with length 3, or THREE.Vector3 expected. Defaulting to [1,1,1]&quot;); options.preScale = new THREE.Vector3(1,1,1); } var scale = options.preScale; // Figure out if this object is a geoGroup and should be positioned and scaled directly, or if its parent var geoGroup; if (obj.userData.isGeoGroup) geoGroup = obj; else if (obj.parent &amp;&amp; obj.parent.userData.isGeoGroup) geoGroup = obj.parent; else return console.error(&quot;Cannot set geographic coordinates of object that does not have an associated GeoGroup. Object must be added to scene with 'addAtCoordinate()'.&quot;) if(options.scaleToLatitude) { // Scale the model so that its units are interpreted as meters at the given latitude var pixelsPerMeter = this.projectedUnitsPerMeter(lnglat[1]); scale.multiplyScalar(pixelsPerMeter); } geoGroup.scale.copy(scale); geoGroup.position.copy(this.projectToWorld(lnglat)); obj.coordinates = lnglat; return obj; } addGeoreferencedMesh(mesh, options) { /* Place the mesh on the map, assuming its internal (x,y) coordinates are already in (longitude, latitude) format TODO: write this */ } /** * 添加默认地面 */ addGround(){ var geometry = new THREE.PlaneGeometry( PigeonGLConstants.WORLD_SIZE, PigeonGLConstants.WORLD_SIZE ); var material = new THREE.MeshPhongMaterial( {color: this.map.groundColor||0x666666, shininess: 30 } ); var plane = new THREE.Mesh( geometry, material ); // plane.position.x = plane.position.y = - PigeonGLConstants.WORLD_SIZE/2; plane.position.z = -0.01; this.addAtCoordinate(plane,this.map.center,{scaleToLatitude: true, preScale:100}); } /** * */ getDataLayer(id) { for(var i = 0; i &lt; this.layers.length; i++) { if (this.layer.id === id) return layer; } } /** * 移除物体mesh * @param {Object} obj - mesh */ remove(obj) { this.world.remove(obj); } /** * 设置默认光源 */ setupDefaultLights() { this.scene.add( new THREE.AmbientLight( 0xCCCCCC ) ); var sunlight = new THREE.DirectionalLight(0xffffff, 0.5); sunlight.position.set(0,800,1000); sunlight.matrixWorldNeedsUpdate = true; this.world.add(sunlight); } } module.exports = exports = Map; × Search results Close "},"Camera_CameraControl.js.html":{"id":"Camera_CameraControl.js.html","title":"Source: Camera/CameraControl.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Camera/CameraControl.js var utils = require(&quot;../Utils/Utils.js&quot;); var PigeonGLConstants = require(&quot;../constants.js&quot;); /** * 相机控制类 * @class * @param {object} map - 包含位置信息的地图对象 * @param {object} camera - 相机对象 * @param {object} world - 世界对象 */ function CameraControl(map, camera, world) { this.map = map; this.camera = camera; this.active = true; this.camera.matrixAutoUpdate = false; // We're in charge of the camera now! // Postion and configure the world group so we can scale it appropriately when the camera zooms this.world = world || new THREE.Group(); this.world.position.x = this.world.position.y = PigeonGLConstants.WORLD_SIZE/2 this.world.matrixAutoUpdate = false; // Listen for move events from the map and update the Three.js camera var _this = this; this.listenMapChange(); } CameraControl.prototype = { /** * 更新地图参数，当this.map的参数发生变化时，需要执行该函数同步变化 */ updateMap(map){ this.map = Object.assign(this.map,map); var _this = this; if(this.map.MAP_TYPE=='mapbox'){ this.updateCamera(); }else if(this.map.MAP_TYPE=='amap'){ this.updateCamera(); }else if(this.map.MAP_TYPE=='none'){ _this.initMapTransform(); _this.updateCamera(); } }, /** * 监听地图瓦片层的变化，并同步执行updateCamera()同步相机 */ listenMapChange(){ var _this = this; //更新地图对象 this.updateMap(this.map); //监听事件 if(this.map.MAP_TYPE=='mapbox'){ this.map.on('move', function() { _this.updateCamera(); }); }else if(this.map.MAP_TYPE=='amap'){ this.map.on('move', function() { _this.updateCamera(); }); }else if(this.map.MAP_TYPE=='none'){ //无事件操作 } }, /** * 重新初始化没有地图瓦片层时的位置参数 */ initMapTransform(){ var transform = {}; var config = this.map; transform.width = this.map.width; transform.height = this.map.height; transform.x = this.lngX(this.map.center[0],this.map.zoom); transform.y = this.latY(this.map.center[1],this.map.zoom); transform.scale = this.getScale(this.map.zoom); transform._pitch = (this.map.pitch*Math.PI/180)||0; transform.angle = (this.map.rotation*Math.PI/180)||0; this.map.transform = transform; }, /** * 计算地图中心的x值 */ lngX(lng,zoom) { return (180 + lng) * this.getWorldSize(zoom)/ 360; }, /** * 计算地图中心的y值 */ latY(lat,zoom) { const y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)); return (180 - y) * this.getWorldSize(zoom) / 360; }, /** * 获取地图应该被放大到的尺寸 */ getWorldSize(zoom){ return PigeonGLConstants.WORLD_SIZE * this.getScale(zoom); }, /** * 获取地图放大倍数 * @param {number} zoom - 地图zoom */ getScale(zoom){ return Math.pow(2,zoom||1); }, /** * 设置地图中心 * @param {Array} center - [lng,lat] */ setCenter(center){ var _this = this; if(this.map.MAP_TYPE=='mapbox'){ this.map.setCenter(center) }else if(this.map.MAP_TYPE=='amap'){ this.map.setCenter(center) }else if(this.map.MAP_TYPE=='none'){ this.map.center = center; _this.initMapTransform(); } }, /** * 设置旋转角度 * @param {number} deg - 旋转的角度（！不是弧度） */ setRotation(rad){ var _this = this; this.map.rotation = rad; if(this.map.MAP_TYPE=='mapbox'){ this.map.setRotation(center) }else if(this.map.MAP_TYPE=='amap'){ this.map.setRotation(center) }else if(this.map.MAP_TYPE=='none'){ this.map.transform.angle = this.map.rotation*Math.PI/180; } }, /** * 设置旋转的俯角 * @param {number} deg - 俯视的角度 */ setPitch(rad){ var _this = this; this.map.pitch = rad; this.map.rotation = rad; if(this.map.MAP_TYPE=='mapbox'){ this.map.setPitch(rad) }else if(this.map.MAP_TYPE=='amap'){ this.map.setPitch(rad) }else if(this.map.MAP_TYPE=='none'){ this.map.transform._pitch = this.map.pitch*Math.PI/180; } }, /** * 更新相机位置，当map位置信息变化时执行 */ updateCamera: function(ev) { if(!this.camera) { console.log('nocamera') return; } // Build a projection matrix, paralleling the code found in Mapbox GL JS const fov = this.map.fov||0.6435011087932844;//*2/Math.pow(this.map.zoom,2); var cameraToCenterDistance = 0.5 / Math.tan(fov / 2) * this.map.transform.height; const halfFov = fov / 2; const groundAngle = Math.PI / 2 + this.map.transform._pitch; const topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov); // Calculate z distance of the farthest fragment that should be rendered. const furthestDistance = Math.cos(Math.PI / 2 - this.map.transform._pitch) * topHalfSurfaceDistance + cameraToCenterDistance; // Add a bit extra to avoid precision problems when a fragment's distance is exactly `furthestDistance` const farZ = furthestDistance * 1.01; this.camera.projectionMatrix = utils.makePerspectiveMatrix(fov, this.map.transform.width / this.map.transform.height, 1, farZ); var cameraWorldMatrix = new THREE.Matrix4(); var cameraTranslateZ = new THREE.Matrix4().makeTranslation(0,0,cameraToCenterDistance); var cameraRotateX = new THREE.Matrix4().makeRotationX(this.map.transform._pitch); var cameraRotateZ = new THREE.Matrix4().makeRotationZ(this.map.transform.angle); // Unlike the Mapbox GL JS camera, separate camera translation and rotation out into its world matrix // If this is applied directly to the projection matrix, it will work OK but break raycasting cameraWorldMatrix .premultiply(cameraTranslateZ) .premultiply(cameraRotateX) .premultiply(cameraRotateZ) ; this.camera.matrixWorld.copy(cameraWorldMatrix); var zoomPow = this.map.transform.scale; // Handle scaling and translation of objects in the map in the world's matrix transform, not the camera var scale = new THREE.Matrix4; var translateCenter = new THREE.Matrix4; var translateMap = new THREE.Matrix4; var rotateMap = new THREE.Matrix4; scale.makeScale(zoomPow, zoomPow , zoomPow ); translateCenter.makeTranslation(PigeonGLConstants.WORLD_SIZE/2, -PigeonGLConstants.WORLD_SIZE / 2, 0); translateMap.makeTranslation(-this.map.transform.x, this.map.transform.y , 0); rotateMap.makeRotationZ(Math.PI); this.world.matrix = new THREE.Matrix4; this.world.matrix .premultiply(rotateMap) .premultiply(translateCenter) .premultiply(scale) .premultiply(translateMap) utils.prettyPrintMatrix(this.camera.projectionMatrix.elements); }, } module.exports = exports = CameraControl; × Search results Close "},"Layers_Layer.js.html":{"id":"Layers_Layer.js.html","title":"Source: Layers/Layer.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Layers/Layer.js /** * 图层基础类 * @class */ class Layer{ /** * Layer类的构造函数，会把所有用户参数挂到layer对象上 * @param {object} config - 用户构造函数配置 */ constructor(config){ var _this = this; this._userConfig = config; for(var x in config){ this[x] = config[x] } } /** * 事件监听,用法同jQuery.on */ on(type,listener){ if ( this._listeners === undefined ) this._listeners = {}; var listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } } /** * 触发事件 * @example * this.fire(&quot;change&quot;,event) */ fire(type,event){ if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { var array = listenerArray.slice( 0 ); for ( var i = 0, l = array.length; i &lt; l; i ++ ) { array[ i ].call( this, event ); } } } /** * 关闭事件 * @example * this.off('change',onChange) */ off(type,listener){ if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { if(listener){ var index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } }else{ this._listeners[type] = []; } } } initConfig(config){ } /** * 地图添加图层时调用,由子类实现 * @param {Map} map - PigeonGL.Map实例 */ onAdd(map){ this.pigeonMap = map; } /** * 地图每帧调用该函数 */ update(){ } /** * 移除图层时调用 */ onRemove(){ if(this._listeners){ this._listeners = [] } } } module.exports = Layer; × Search results Close "},"Layers_MapControl.js.html":{"id":"Layers_MapControl.js.html","title":"Source: Layers/MapControl.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Layers/MapControl.js import Layer from './Layer.js'; /** * 地图控制类 * @class * @extends Layer */ class MapControl extends Layer{ defaultParams={ moveSpeed:1, pitchSpeed:0.1, rotateSpeed:0.15 } /** * 构造函数 * @param {Object} config - config * @param {number} config.moveSpeed - 移动速度 * @param {number} config.pitchSpeed - 角度改变速度 * @param {number} config.rotateSpeed - 旋转速度 */ constructor(config){ super(config); for(var x in this.defaultParams){ if(!this[x]){ this[x] = this.defaultParams[x]; } } } onAdd(map){ var _this = this; this.pigeonMap = map; this.map = this.pigeonMap.map;//用户配置或真实地图 this.cameraControl = this.pigeonMap.cameraControl; this.initConfig(); this.listenEvents(); //添加相机更新函数 this.on(&quot;change&quot;,function(){ _this.pigeonMap.fire(&quot;change&quot;) _this.cameraControl.updateMap();//更新用户参数为相机参数 }) } initConfig(){ var transform = {}; }; /** * 监听事件 */ listenEvents(){ var _this = this; var container = this.map.container; this.onDown = function onDown(event){ if(event.button==0){//左键 _this.mouseStatus = 'left' }else if(event.button==2){//右键 _this.mouseStatus = 'right' } _this.mouseDownPosition = { x:event.clientX, y:event.clientY } _this.map.container.addEventListener('mousemove',_this.onMove) } this.onUp = function onUp(event){ _this.mouseStatus = false; _this.map.container.removeEventListener('mousemove',_this.onMove) } this.onMove = function onMove(event){ if(!_this.mouseStatus){ return; } if(_this.mouseStatus=='left'){ let yDis = event.clientY - _this.mouseDownPosition.y; let xDis = event.clientX - _this.mouseDownPosition.x; let distance = Math.sqrt(Math.pow(xDis,2) + Math.pow(yDis,2)); if(distance&lt;0.1)return false; let rotation = (xDis&gt;0?-1:1)*Math.asin(yDis/distance) + _this.map.transform.angle; _this.map.center[0] += (xDis&gt;0?-1:1)*_this.moveSpeed*(distance*Math.cos(rotation))/_this.map.transform.scale; _this.map.center[1] += (xDis&gt;0?-1:1)* _this.moveSpeed*(distance*Math.sin(rotation))/_this.map.transform.scale; _this.cameraControl.updateMap(); /** * 地图移动 * @event MapControl#move * @property {Object} event */ _this.fire(&quot;move&quot;,event)//地图移动 }else if(_this.mouseStatus=='right'){ _this.map.pitch += _this.pitchSpeed*(event.clientY - _this.mouseDownPosition.y); if(_this.map.pitch&gt;90){ _this.map.pitch = 90; }else if(_this.map.pitch&lt;0){ _this.map.pitch = 0; } _this.map.rotation -= _this.rotateSpeed*(event.clientX - _this.mouseDownPosition.x); _this.cameraControl.updateMap(); /** * 地图旋转 * @event MapControl#rotate * @property {Object} event */ _this.fire(&quot;rotate&quot;,event)//地图x旋转 } _this.mouseDownPosition = { x:event.clientX, y:event.clientY } _this.fire(&quot;change&quot;,event) } this.onWheel = function onWheel(event){ _this.map.zoom -= event.deltaY/100; _this.cameraControl.updateMap(); event.preventDefault(); /** * 地图缩放 * @event MapControl#zoom * @property {Object} event - 原生event对象 */ _this.fire(&quot;zoom&quot;,event)//地图缩放 /** * 地图状态发生改变，发生操作时触发 * @event MapControl#change * @property {Object} event - 原生event对象 */ _this.fire(&quot;change&quot;,event) } this.onContextmenu = function onContextmenu(e){ e.preventDefault(); e.stopPropagation(); } this.map.container.addEventListener('mousedown',this.onDown) this.map.container.addEventListener('mouseup',this.onUp) this.map.container.addEventListener('mousemove',this.onMove) this.map.container.addEventListener('wheel',this.onWheel) this.map.container.addEventListener('contextmenu',this.onContextmenu) }; /** * 移除所有监听事件 */ removeListenr(){ this.map.container.removeEventListener('mousedown',this.onDown) this.map.container.removeEventListener('mouseup',this.onUp) this.map.container.removeEventListener('mousemove',this.onMove) this.map.container.removeEventListener('wheel',this.onWheel) this.map.container.removeEventListener('contextmenu',this.onContextmenu) } } module.exports = MapControl; × Search results Close "},"Layers_TextLayer.js.html":{"id":"Layers_TextLayer.js.html","title":"Source: Layers/TextLayer.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Layers/TextLayer.js import Layer from './Layer.js'; /** * 文字图层类 * @extends Layer */ class TextLayer extends Layer{ defaultParams={ font:'14px Arial', color:'#000000', canvasRender:false } texts=[]; textId = 0; constructor(config){ super(config); for(var x in this.defaultParams){ if(!this[x]){ this[x] = this.defaultParams[x]; } } }; //图层添加之后的处理函数 onAdd(map){ this.pigeonMap = map; if(!this.canvasRender){ this.initDom(); }else{ this.initCanvas(); } var _this = this; function change(){ _this.updateText() } this.change = change; this.pigeonMap.on(&quot;change&quot;,change) } initDom(){ this.container = this.pigeonMap.map.container; var div = document.createElement('div'); div.id='text_layer_'+this.id; div.className= 'pigeonGL-text-layer'; div.setAttribute(&quot;width&quot;,this.pigeonMap.map.width); div.setAttribute(&quot;height&quot;,this.pigeonMap.map.height); div.style.position= 'absolute'; div.style.top= '0'; div.style.left= '0'; div.style.zIndex = ++this.pigeonMap.zIndex; this.dom = div; this.container.appendChild(div); } initCanvas(){ this.container = this.pigeonMap.map.container; var canvas = document.createElement('canvas'); canvas.id = 'text_layer_'+this.id; this.container.appendChild(canvas); canvas.setAttribute(&quot;width&quot;,this.pigeonMap.map.width); canvas.setAttribute(&quot;height&quot;,this.pigeonMap.map.height); canvas.style.position= 'absolute'; canvas.style.top= '0'; canvas.style.left= '0'; canvas.style.zIndex = ++this.pigeonMap.zIndex; this.canvas = canvas; } /** * @params {color,text,lnglat,fontSize} */ addText(options){ options.id = options.id||('_text_'+this.textId++); this.texts.push(options); return options; } drawText(){ if(!this.canvasRender){ this.drawDomText(); }else{ this.drawCanvasText(); } } drawDomText(){ this.dom.innerHTML = '';//清空 for(var x in this.texts){ let xy = this.pigeonMap.projectToScreen(this.texts[x].lnglat); let span = document.createElement('span'); span.innerHTML = this.texts[x].text; this.dom.appendChild(span); } } drawCanvasText(){ var ctx = this.canvas.getContext(&quot;2d&quot;); ctx.clearRect(0,0,this.canvas.width,this.canvas.height); for(var x in this.texts){ let xy = this.pigeonMap.projectToScreen(this.texts[x].lnglat); ctx.font= this.texts[x].font||this.font; ctx.fillStyle= this.texts[x].color||this.color; ctx.fillText(this.texts[x].text,xy.x,xy.y); } } updateDomText(){ let span = this.dom.querySelectorAll('span'); for(var x in this.texts){ let xy = this.pigeonMap.projectToScreen(this.texts[x].lnglat); span[x].style.top = xy.y+'px'; span[x].style.left = xy.x+'px'; } } /** * 删除某个ID的文字 */ removeText(id){ for(var x in this.texts){ if(this.texts[x].id==id){ this.texts.splice(x,1); this.drawText(); return; } } } update(){ } updateText(){ if(!this.canvasRender){ this.updateDomText(); }else{ this.drawCanvasText(); } } /** * 获取某个文字对象 */ getText(id){ for(var x in this.texts){ if(this.texts[x].id==id){ return this.text[x] } } } onRemove(){ this.pigeonMap.off('change',this.change)//去除map对该对象的引用 this._listeners = null; } /** * 获取某个文字对象的索引 */ getTextIndex(id){ for(var x in this.texts){ if(this.texts[x].id==id){ return x; } } } }; module.exports = TextLayer; × Search results Close "},"Layers_ThirdPersonView.js.html":{"id":"Layers_ThirdPersonView.js.html","title":"Source: Layers/ThirdPersonView.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Layers/ThirdPersonView.js import Layer from './Layer.js'; /** * 第三人称视角图层 * @extends Layer */ class ThirdPersonLayer extends Layer{ defaultParams={ target : null,//跟踪物体 viewRotation : 0,//观看视角 targetRotation : 0 ,//观看物体默认旋转角度 autoUpdate :false } /** * 构造函数 * @param {Object} target - 需要摄像机跟随的物体 * @param {Number} viewRotation - 观看视角（deg） * @param {Number} targetRotation - 物体初始旋转角度，用来配合摄像机位置 (deg) */ constructor(config){ super(config); for(var x in this.defaultParams){ if(!this[x]){ this[x] = this.defaultParams[x]; } } }; //图层添加之后的处理函数 onAdd(map){ this.pigeonMap = map; this.initCamera(); } initCamera(){ } update(){ if(this.autoUpdate) this.updateCamera(); } /** * 更新相机，物体移动后需要更新相机，重新计算相机位置 */ updateCamera(){ if(!this.target)return false; let lnglat = this.target.coordinates; this.pigeonMap.cameraControl.setRotation(-this.target.rotation.z*180/Math.PI + this.targetRotation + this.viewRotation); this.pigeonMap.cameraControl.setCenter(lnglat); this.pigeonMap.cameraControl.updateCamera(); } }; module.exports = ThirdPersonLayer; × Search results Close "},"Loaders_MTLLoader.js.html":{"id":"Loaders_MTLLoader.js.html","title":"Source: Loaders/MTLLoader.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Loaders/MTLLoader.js /** * Loads a Wavefront .mtl file specifying materials * @class * @author angelxuanchang */ const MTLLoader = function ( manager ) { this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager; }; MTLLoader.prototype = { constructor: MTLLoader, /** * Loads and parses a MTL asset from a URL. * * @param {String} url - URL to the MTL file. * @param {Function} [onLoad] - Callback invoked with the loaded object. * @param {Function} [onProgress] - Callback for download progress. * @param {Function} [onError] - Callback for download errors. * * @see setPath setTexturePath * * @note In order for relative texture references to resolve correctly * you must call setPath and/or setTexturePath explicitly prior to load. */ load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new THREE.FileLoader( this.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { onLoad( scope.parse( text ) ); }, onProgress, onError ); }, /** * Set base path for resolving references. * If set this path will be prepended to each loaded and found reference. * * @see setTexturePath * @param {String} path * * @example * mtlLoader.setPath( 'assets/obj/' ); * mtlLoader.load( 'my.mtl', ... ); */ setPath: function ( path ) { this.path = path; }, /** * Set base path for resolving texture references. * If set this path will be prepended found texture reference. * If not set and setPath is, it will be used as texture base path. * * @see setPath * @param {String} path * * @example * mtlLoader.setPath( 'assets/obj/' ); * mtlLoader.setTexturePath( 'assets/textures/' ); * mtlLoader.load( 'my.mtl', ... ); */ setTexturePath: function ( path ) { this.texturePath = path; }, setBaseUrl: function ( path ) { console.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' ); this.setTexturePath( path ); }, setCrossOrigin: function ( value ) { this.crossOrigin = value; }, setMaterialOptions: function ( value ) { this.materialOptions = value; }, /** * Parses a MTL file. * * @param {String} text - Content of MTL file * @return {THREE.MTLLoader.MaterialCreator} * * @see setPath setTexturePath * * @note In order for relative texture references to resolve correctly * you must call setPath and/or setTexturePath explicitly prior to parse. */ parse: function ( text ) { var lines = text.split( '\\n' ); var info = {}; var delimiter_pattern = /\\s+/; var materialsInfo = {}; for ( var i = 0; i &lt; lines.length; i ++ ) { var line = lines[ i ]; line = line.trim(); if ( line.length === 0 || line.charAt( 0 ) === '#' ) { // Blank line or comment ignore continue; } var pos = line.indexOf( ' ' ); var key = ( pos &gt;= 0 ) ? line.substring( 0, pos ) : line; key = key.toLowerCase(); var value = ( pos &gt;= 0 ) ? line.substring( pos + 1 ) : ''; value = value.trim(); if ( key === 'newmtl' ) { // New material info = { name: value }; materialsInfo[ value ] = info; } else if ( info ) { if ( key === 'ka' || key === 'kd' || key === 'ks' ) { var ss = value.split( delimiter_pattern, 3 ); info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ]; } else { info[ key ] = value; } } } var materialCreator = new MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions ); materialCreator.setCrossOrigin( this.crossOrigin ); materialCreator.setManager( this.manager ); materialCreator.setMaterials( materialsInfo ); return materialCreator; } }; /** * Create a new THREE-MTLLoader.MaterialCreator * @param baseUrl - Url relative to which textures are loaded * @param options - Set of options on how to construct the materials * side: Which side to apply the material * THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide * wrap: What type of wrapping to apply for textures * THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping * normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 * Default: false, assumed to be already normalized * ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's * Default: false */ MTLLoader.MaterialCreator = function ( baseUrl, options ) { this.baseUrl = baseUrl || ''; this.options = options; this.materialsInfo = {}; this.materials = {}; this.materialsArray = []; this.nameLookup = {}; this.side = ( this.options &amp;&amp; this.options.side ) ? this.options.side : THREE.FrontSide; this.wrap = ( this.options &amp;&amp; this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping; }; MTLLoader.MaterialCreator.prototype = { constructor: MTLLoader.MaterialCreator, setCrossOrigin: function ( value ) { this.crossOrigin = value; }, setManager: function ( value ) { this.manager = value; }, setMaterials: function ( materialsInfo ) { this.materialsInfo = this.convert( materialsInfo ); this.materials = {}; this.materialsArray = []; this.nameLookup = {}; }, convert: function ( materialsInfo ) { if ( ! this.options ) return materialsInfo; var converted = {}; for ( var mn in materialsInfo ) { // Convert materials info into normalized form based on options var mat = materialsInfo[ mn ]; var covmat = {}; converted[ mn ] = covmat; for ( var prop in mat ) { var save = true; var value = mat[ prop ]; var lprop = prop.toLowerCase(); switch ( lprop ) { case 'kd': case 'ka': case 'ks': // Diffuse color (color under white light) using RGB values if ( this.options &amp;&amp; this.options.normalizeRGB ) { value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ]; } if ( this.options &amp;&amp; this.options.ignoreZeroRGBs ) { if ( value[ 0 ] === 0 &amp;&amp; value[ 1 ] === 0 &amp;&amp; value[ 2 ] === 0 ) { // ignore save = false; } } break; default: break; } if ( save ) { covmat[ lprop ] = value; } } } return converted; }, preload: function () { for ( var mn in this.materialsInfo ) { this.create( mn ); } }, getIndex: function ( materialName ) { return this.nameLookup[ materialName ]; }, getAsArray: function () { var index = 0; for ( var mn in this.materialsInfo ) { this.materialsArray[ index ] = this.create( mn ); this.nameLookup[ mn ] = index; index ++; } return this.materialsArray; }, create: function ( materialName ) { if ( this.materials[ materialName ] === undefined ) { this.createMaterial_( materialName ); } return this.materials[ materialName ]; }, createMaterial_: function ( materialName ) { // Create material var scope = this; var mat = this.materialsInfo[ materialName ]; var params = { name: materialName, side: this.side }; function resolveURL( baseUrl, url ) { if ( typeof url !== 'string' || url === '' ) return ''; // Absolute URL if ( /^https?:\\/\\//i.test( url ) ) return url; return baseUrl + url; } function setMapForType( mapType, value ) { if ( params[ mapType ] ) return; // Keep the first encountered texture var texParams = scope.getTextureParams( value, params ); var map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) ); map.repeat.copy( texParams.scale ); map.offset.copy( texParams.offset ); map.wrapS = scope.wrap; map.wrapT = scope.wrap; params[ mapType ] = map; } for ( var prop in mat ) { var value = mat[ prop ]; if ( value === '' ) continue; switch ( prop.toLowerCase() ) { // Ns is material specular exponent case 'kd': // Diffuse color (color under white light) using RGB values params.color = new THREE.Color().fromArray( value ); break; case 'ks': // Specular color (color when light is reflected from shiny surface) using RGB values params.specular = new THREE.Color().fromArray( value ); break; case 'map_kd': // Diffuse texture map setMapForType( &quot;map&quot;, value ); break; case 'map_ks': // Specular map setMapForType( &quot;specularMap&quot;, value ); break; case 'map_bump': case 'bump': // Bump texture map setMapForType( &quot;bumpMap&quot;, value ); break; case 'ns': // The specular exponent (defines the focus of the specular highlight) // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000. params.shininess = parseFloat( value ); break; case 'd': if ( value &lt; 1 ) { params.opacity = value; params.transparent = true; } break; case 'Tr': if ( value &gt; 0 ) { params.opacity = 1 - value; params.transparent = true; } break; default: break; } } this.materials[ materialName ] = new THREE.MeshPhongMaterial( params ); return this.materials[ materialName ]; }, getTextureParams: function ( value, matParams ) { var texParams = { scale: new THREE.Vector2( 1, 1 ), offset: new THREE.Vector2( 0, 0 ) }; var items = value.split( /\\s+/ ); var pos; pos = items.indexOf( '-bm' ); if ( pos &gt;= 0 ) { matParams.bumpScale = parseFloat( items[ pos + 1 ] ); items.splice( pos, 2 ); } pos = items.indexOf( '-s' ); if ( pos &gt;= 0 ) { texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) ); items.splice( pos, 4 ); // we expect 3 parameters here! } pos = items.indexOf( '-o' ); if ( pos &gt;= 0 ) { texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) ); items.splice( pos, 4 ); // we expect 3 parameters here! } texParams.url = items.join( ' ' ).trim(); return texParams; }, loadTexture: function ( url, mapping, onLoad, onProgress, onError ) { var texture; var loader = THREE.Loader.Handlers.get( url ); var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager; if ( loader === null ) { loader = new THREE.TextureLoader( manager ); } if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin ); texture = loader.load( url, onLoad, onProgress, onError ); if ( mapping !== undefined ) texture.mapping = mapping; return texture; } }; module.exports = exports = MTLLoader; × Search results Close "},"Loaders_OBJLoader.js.html":{"id":"Loaders_OBJLoader.js.html","title":"Source: Loaders/OBJLoader.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: Loaders/OBJLoader.js /** * @class * @author mrdoob / http://mrdoob.com/ */ const OBJLoader = function ( manager ) { this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager; this.materials = null; this.regexp = { // v float float float vertex_pattern : /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/, // vn float float float normal_pattern : /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/, // vt float float uv_pattern : /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/, // f vertex vertex vertex face_vertex : /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/, // f vertex/uv vertex/uv vertex/uv face_vertex_uv : /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/, // f vertex/uv/normal vertex/uv/normal vertex/uv/normal face_vertex_uv_normal : /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/, // f vertex//normal vertex//normal vertex//normal face_vertex_normal : /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/, // o object_name | g group_name object_pattern : /^[og]\\s*(.+)?/, // s boolean smoothing_pattern : /^s\\s+(\\d+|on|off)/, // mtllib file_reference material_library_pattern : /^mtllib /, // usemtl material_name material_use_pattern : /^usemtl / }; }; OBJLoader.prototype = { constructor: OBJLoader, load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new THREE.FileLoader( scope.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { onLoad( scope.parse( text ) ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; }, setMaterials: function ( materials ) { this.materials = materials; }, _createParserState : function () { var state = { objects : [], object : {}, vertices : [], normals : [], uvs : [], materialLibraries : [], startObject: function ( name, fromDeclaration ) { // If the current object (initial from reset) is not from a g/o declaration in the parsed // file. We need to use it for the first parsed g/o to keep things in sync. if ( this.object &amp;&amp; this.object.fromDeclaration === false ) { this.object.name = name; this.object.fromDeclaration = ( fromDeclaration !== false ); return; } var previousMaterial = ( this.object &amp;&amp; typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined ); if ( this.object &amp;&amp; typeof this.object._finalize === 'function' ) { this.object._finalize( true ); } this.object = { name : name || '', fromDeclaration : ( fromDeclaration !== false ), geometry : { vertices : [], normals : [], uvs : [] }, materials : [], smooth : true, startMaterial : function( name, libraries ) { var previous = this._finalize( false ); // New usemtl declaration overwrites an inherited material, except if faces were declared // after the material, then it must be preserved for proper MultiMaterial continuation. if ( previous &amp;&amp; ( previous.inherited || previous.groupCount &lt;= 0 ) ) { this.materials.splice( previous.index, 1 ); } var material = { index : this.materials.length, name : name || '', mtllib : ( Array.isArray( libraries ) &amp;&amp; libraries.length &gt; 0 ? libraries[ libraries.length - 1 ] : '' ), smooth : ( previous !== undefined ? previous.smooth : this.smooth ), groupStart : ( previous !== undefined ? previous.groupEnd : 0 ), groupEnd : -1, groupCount : -1, inherited : false, clone : function( index ) { var cloned = { index : ( typeof index === 'number' ? index : this.index ), name : this.name, mtllib : this.mtllib, smooth : this.smooth, groupStart : 0, groupEnd : -1, groupCount : -1, inherited : false }; cloned.clone = this.clone.bind(cloned); return cloned; } }; this.materials.push( material ); return material; }, currentMaterial : function() { if ( this.materials.length &gt; 0 ) { return this.materials[ this.materials.length - 1 ]; } return undefined; }, _finalize : function( end ) { var lastMultiMaterial = this.currentMaterial(); if ( lastMultiMaterial &amp;&amp; lastMultiMaterial.groupEnd === -1 ) { lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3; lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart; lastMultiMaterial.inherited = false; } // Ignore objects tail materials if no face declarations followed them before a new o/g started. if ( end &amp;&amp; this.materials.length &gt; 1 ) { for ( var mi = this.materials.length - 1; mi &gt;= 0; mi-- ) { if ( this.materials[mi].groupCount &lt;= 0 ) { this.materials.splice( mi, 1 ); } } } // Guarantee at least one empty material, this makes the creation later more straight forward. if ( end &amp;&amp; this.materials.length === 0 ) { this.materials.push({ name : '', smooth : this.smooth }); } return lastMultiMaterial; } }; // Inherit previous objects material. // Spec tells us that a declared material must be set to all objects until a new material is declared. // If a usemtl declaration is encountered while this new object is being parsed, it will // overwrite the inherited material. Exception being that there was already face declarations // to the inherited material, then it will be preserved for proper MultiMaterial continuation. if ( previousMaterial &amp;&amp; previousMaterial.name &amp;&amp; typeof previousMaterial.clone === &quot;function&quot; ) { var declared = previousMaterial.clone( 0 ); declared.inherited = true; this.object.materials.push( declared ); } this.objects.push( this.object ); }, finalize : function() { if ( this.object &amp;&amp; typeof this.object._finalize === 'function' ) { this.object._finalize( true ); } }, parseVertexIndex: function ( value, len ) { var index = parseInt( value, 10 ); return ( index &gt;= 0 ? index - 1 : index + len / 3 ) * 3; }, parseNormalIndex: function ( value, len ) { var index = parseInt( value, 10 ); return ( index &gt;= 0 ? index - 1 : index + len / 3 ) * 3; }, parseUVIndex: function ( value, len ) { var index = parseInt( value, 10 ); return ( index &gt;= 0 ? index - 1 : index + len / 2 ) * 2; }, addVertex: function ( a, b, c ) { var src = this.vertices; var dst = this.object.geometry.vertices; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ a + 2 ] ); dst.push( src[ b + 0 ] ); dst.push( src[ b + 1 ] ); dst.push( src[ b + 2 ] ); dst.push( src[ c + 0 ] ); dst.push( src[ c + 1 ] ); dst.push( src[ c + 2 ] ); }, addVertexLine: function ( a ) { var src = this.vertices; var dst = this.object.geometry.vertices; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ a + 2 ] ); }, addNormal : function ( a, b, c ) { var src = this.normals; var dst = this.object.geometry.normals; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ a + 2 ] ); dst.push( src[ b + 0 ] ); dst.push( src[ b + 1 ] ); dst.push( src[ b + 2 ] ); dst.push( src[ c + 0 ] ); dst.push( src[ c + 1 ] ); dst.push( src[ c + 2 ] ); }, addUV: function ( a, b, c ) { var src = this.uvs; var dst = this.object.geometry.uvs; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ b + 0 ] ); dst.push( src[ b + 1 ] ); dst.push( src[ c + 0 ] ); dst.push( src[ c + 1 ] ); }, addUVLine: function ( a ) { var src = this.uvs; var dst = this.object.geometry.uvs; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); }, addFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) { var vLen = this.vertices.length; var ia = this.parseVertexIndex( a, vLen ); var ib = this.parseVertexIndex( b, vLen ); var ic = this.parseVertexIndex( c, vLen ); var id; if ( d === undefined ) { this.addVertex( ia, ib, ic ); } else { id = this.parseVertexIndex( d, vLen ); this.addVertex( ia, ib, id ); this.addVertex( ib, ic, id ); } if ( ua !== undefined ) { var uvLen = this.uvs.length; ia = this.parseUVIndex( ua, uvLen ); ib = this.parseUVIndex( ub, uvLen ); ic = this.parseUVIndex( uc, uvLen ); if ( d === undefined ) { this.addUV( ia, ib, ic ); } else { id = this.parseUVIndex( ud, uvLen ); this.addUV( ia, ib, id ); this.addUV( ib, ic, id ); } } if ( na !== undefined ) { // Normals are many times the same. If so, skip function call and parseInt. var nLen = this.normals.length; ia = this.parseNormalIndex( na, nLen ); ib = na === nb ? ia : this.parseNormalIndex( nb, nLen ); ic = na === nc ? ia : this.parseNormalIndex( nc, nLen ); if ( d === undefined ) { this.addNormal( ia, ib, ic ); } else { id = this.parseNormalIndex( nd, nLen ); this.addNormal( ia, ib, id ); this.addNormal( ib, ic, id ); } } }, addLineGeometry: function ( vertices, uvs ) { this.object.geometry.type = 'Line'; var vLen = this.vertices.length; var uvLen = this.uvs.length; for ( var vi = 0, l = vertices.length; vi &lt; l; vi ++ ) { this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) ); } for ( var uvi = 0, l = uvs.length; uvi &lt; l; uvi ++ ) { this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) ); } } }; state.startObject( '', false ); return state; }, parse: function ( text ) { //console.time( 'OBJLoader' ); var state = this._createParserState(); if ( text.indexOf( '\\r\\n' ) !== - 1 ) { // This is faster than String.split with regex that splits on both text = text.replace( /\\r\\n/g, '\\n' ); } if ( text.indexOf( '\\\\\\n' ) !== - 1) { // join lines separated by a line continuation character (\\) text = text.replace( /\\\\\\n/g, '' ); } var lines = text.split( '\\n' ); var line = '', lineFirstChar = '', lineSecondChar = ''; var lineLength = 0; var result = []; // Faster to just trim left side of the line. Use if available. var trimLeft = ( typeof ''.trimLeft === 'function' ); for ( var i = 0, l = lines.length; i &lt; l; i ++ ) { line = lines[ i ]; line = trimLeft ? line.trimLeft() : line.trim(); lineLength = line.length; if ( lineLength === 0 ) continue; lineFirstChar = line.charAt( 0 ); // @todo invoke passed in handler if any if ( lineFirstChar === '#' ) continue; if ( lineFirstChar === 'v' ) { lineSecondChar = line.charAt( 1 ); if ( lineSecondChar === ' ' &amp;&amp; ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) { // 0 1 2 3 // [&quot;v 1.0 2.0 3.0&quot;, &quot;1.0&quot;, &quot;2.0&quot;, &quot;3.0&quot;] state.vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) ); } else if ( lineSecondChar === 'n' &amp;&amp; ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) { // 0 1 2 3 // [&quot;vn 1.0 2.0 3.0&quot;, &quot;1.0&quot;, &quot;2.0&quot;, &quot;3.0&quot;] state.normals.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) ); } else if ( lineSecondChar === 't' &amp;&amp; ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) { // 0 1 2 // [&quot;vt 0.1 0.2&quot;, &quot;0.1&quot;, &quot;0.2&quot;] state.uvs.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ) ); } else { throw new Error( &quot;Unexpected vertex/normal/uv line: '&quot; + line + &quot;'&quot; ); } } else if ( lineFirstChar === &quot;f&quot; ) { if ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) { // f vertex/uv/normal vertex/uv/normal vertex/uv/normal // 0 1 2 3 4 5 6 7 8 9 10 11 12 // [&quot;f 1/1/1 2/2/2 3/3/3&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, undefined, undefined, undefined] state.addFace( result[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ], result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ], result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ); } else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) { // f vertex/uv vertex/uv vertex/uv // 0 1 2 3 4 5 6 7 8 // [&quot;f 1/1 2/2 3/3&quot;, &quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, undefined, undefined] state.addFace( result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ], result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ] ); } else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) { // f vertex//normal vertex//normal vertex//normal // 0 1 2 3 4 5 6 7 8 // [&quot;f 1//1 2//2 3//3&quot;, &quot;1&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, undefined, undefined] state.addFace( result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ], undefined, undefined, undefined, undefined, result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ] ); } else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) { // f vertex vertex vertex // 0 1 2 3 4 // [&quot;f 1 2 3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, undefined] state.addFace( result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ); } else { throw new Error( &quot;Unexpected face line: '&quot; + line + &quot;'&quot; ); } } else if ( lineFirstChar === &quot;l&quot; ) { var lineParts = line.substring( 1 ).trim().split( &quot; &quot; ); var lineVertices = [], lineUVs = []; if ( line.indexOf( &quot;/&quot; ) === - 1 ) { lineVertices = lineParts; } else { for ( var li = 0, llen = lineParts.length; li &lt; llen; li ++ ) { var parts = lineParts[ li ].split( &quot;/&quot; ); if ( parts[ 0 ] !== &quot;&quot; ) lineVertices.push( parts[ 0 ] ); if ( parts[ 1 ] !== &quot;&quot; ) lineUVs.push( parts[ 1 ] ); } } state.addLineGeometry( lineVertices, lineUVs ); } else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) { // o object_name // or // g group_name // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869 // var name = result[ 0 ].substr( 1 ).trim(); var name = ( &quot; &quot; + result[ 0 ].substr( 1 ).trim() ).substr( 1 ); state.startObject( name ); } else if ( this.regexp.material_use_pattern.test( line ) ) { // material state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries ); } else if ( this.regexp.material_library_pattern.test( line ) ) { // mtl file state.materialLibraries.push( line.substring( 7 ).trim() ); } else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) { // smooth shading // @todo Handle files that have varying smooth values for a set of faces inside one geometry, // but does not define a usemtl for each face set. // This should be detected and a dummy material created (later MultiMaterial and geometry groups). // This requires some care to not create extra material on each smooth value for &quot;normal&quot; obj files. // where explicit usemtl defines geometry groups. // Example asset: examples/models/obj/cerberus/Cerberus.obj var value = result[ 1 ].trim().toLowerCase(); state.object.smooth = ( value === '1' || value === 'on' ); var material = state.object.currentMaterial(); if ( material ) { material.smooth = state.object.smooth; } } else { // Handle null terminated files without exception if ( line === '\\0' ) continue; throw new Error( &quot;Unexpected line: '&quot; + line + &quot;'&quot; ); } } state.finalize(); var container = new THREE.Group(); container.materialLibraries = [].concat( state.materialLibraries ); for ( var i = 0, l = state.objects.length; i &lt; l; i ++ ) { var object = state.objects[ i ]; var geometry = object.geometry; var materials = object.materials; var isLine = ( geometry.type === 'Line' ); // Skip o/g line declarations that did not follow with any faces if ( geometry.vertices.length === 0 ) continue; var buffergeometry = new THREE.BufferGeometry(); buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) ); if ( geometry.normals.length &gt; 0 ) { buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) ); } else { buffergeometry.computeVertexNormals(); } if ( geometry.uvs.length &gt; 0 ) { buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) ); } // Create materials var createdMaterials = []; for ( var mi = 0, miLen = materials.length; mi &lt; miLen ; mi++ ) { var sourceMaterial = materials[mi]; var material = undefined; if ( this.materials !== null ) { material = this.materials.create( sourceMaterial.name ); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material. if ( isLine &amp;&amp; material &amp;&amp; ! ( material instanceof THREE.LineBasicMaterial ) ) { var materialLine = new THREE.LineBasicMaterial(); materialLine.copy( material ); materialLine.lights = false; material = materialLine; } } if ( ! material ) { material = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() ); material.name = sourceMaterial.name; } material.flatShading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading; createdMaterials.push(material); } // Create mesh var mesh; if ( createdMaterials.length &gt; 1 ) { for ( var mi = 0, miLen = materials.length; mi &lt; miLen ; mi++ ) { var sourceMaterial = materials[mi]; buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi ); } var multiMaterial = new THREE.MultiMaterial( createdMaterials ); mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, multiMaterial ) : new THREE.LineSegments( buffergeometry, multiMaterial ) ); } else { mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) ); } mesh.name = object.name; container.add( mesh ); } //console.timeEnd( 'OBJLoader' ); return container; } }; module.exports = exports = OBJLoader; × Search results Close "},"PigeonGL.js.html":{"id":"PigeonGL.js.html","title":"Source: PigeonGL.js","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Source: PigeonGL.js /** * window.PigeonGL * @example * ``` * new PigeonGL.Map() * ``` * @author mizy.mz 17/12/06 * @global * @property {Objcet} MTLLoader - MTL Loaders * @property {Objcet} OBJLoader - OBJ Loaders * @property {Map} Map - Map类，初始化:new PigeonGL.Map() * @property {Layer} Layer - 核心图层基类，不可被实例化， * @property {SymbolLayer3D} SymbolLayer3D - 3d模型图层 * @property {ThirdPersonView} ThirdPersonView - 第三人称视角控制层 * @property {MapControl} MapControl - 地图控制图层 * @property {TextLayer} TextLayer - 文字图层 */ const PigeonGL = { MTLLoader : require(&quot;./Loaders/MTLLoader.js&quot;), OBJLoader : require(&quot;./Loaders/OBJLoader.js&quot;), //core Map:require(&quot;./Map.js&quot;), Layer:require(&quot;./Layers/Layer.js&quot;), //插件 SymbolLayer3D:require(&quot;./Layers/SymbolLayer3D.js&quot;), ThirdPersonView:require(&quot;./Layers/ThirdPersonView.js&quot;), MapControl:require(&quot;./Layers/MapControl.js&quot;), TextLayer:require(&quot;./Layers/TextLayer.js&quot;) } window.PigeonGL = PigeonGL; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Global Members &lt;constant&gt; PigeonGL window.PigeonGL Properties: Name Type Description MTLLoader Objcet MTL Loaders OBJLoader Objcet OBJ Loaders Map Map Map类，初始化:new PigeonGL.Map() Layer Layer 核心图层基类，不可被实例化， SymbolLayer3D SymbolLayer3D 3d模型图层 ThirdPersonView ThirdPersonView 第三人称视角控制层 MapControl MapControl 地图控制图层 TextLayer TextLayer 文字图层 Author: mizy.mz 17/12/06 Source: PigeonGL.js, line 18 Example ``` new PigeonGL.Map() ``` × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Classes Classes Map CameraControl Layer MapControl TextLayer ThirdPersonLayer MTLLoader OBJLoader Events move 地图移动 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 86 rotate 地图旋转 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 102 zoom 地图缩放 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 120 change 地图状态发生改变，发生操作时触发 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 127 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL pigeon-gl信鸽3d地图 demoing... api详情见./doc 编译npm run build文档npm run doc × Search results Close "},"Map.html":{"id":"Map.html","title":"Class: Map","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: Map Map 信鸽地图地图核心类，用于生成3d空间地图底层 new Map(map) 地图构造函数 Parameters: Name Type Description map Object 地图绘制对象,目前支持高德,mapbox或者纯空间 Properties Name Type Description width Number 地图宽度, default:1000 height Number 地图高度, default:600 rotation Number 地图旋转角度, default:60 pitch Number 地图俯视角度, default:45 center Array 地图默认中心位置经纬度, default:[0,0] zoom Number 地图缩放级别,default:21 Source: Map.js, line 9 Members scene Properties: Name Type Description scene Object this.scene为three.js场景 Source: Map.js, line 54 camera Properties: Name Type Description camera Object this.camera.js场景 Source: Map.js, line 61 layers Properties: Name Type Description layers Object 图层集合 Source: Map.js, line 66 world Properties: Name Type Description world Object this.world为世界模型组，所有模型被添加到该组内 Source: Map.js, line 75 cameraControl Properties: Name Type Description cameraControl CameraControl 摄像机控制类 Source: Map.js, line 82 map Properties: Name Type Description map Object map对象，包含map的位置信息等，如果是高德或mapbox则为地图对象 默认值为rotation:0, width:1000, height:600, pitch:45, zoom:21, center:[0,0] Source: Map.js, line 114 Methods update() 自动刷新渲染，可以改变this.status=='top',停止自动刷新 Source: Map.js, line 130 addLayer(layer) 添加图层 Parameters: Name Type Description layer Layer 图层 Source: Map.js, line 152 removeLayer(layer) 删除图层 Parameters: Name Type Description layer Layer 图层 Source: Map.js, line 162 projectToWorld(coords) 投影到3d坐标系 Parameters: Name Type Description coords Array 经纬度 [lng,lat],经度在前，纬度在后 Source: Map.js, line 177 Returns: Vecotor3 - Type Object projectedUnitsPerMeter(latitude) 获取该维度的1m缩放比例 Parameters: Name Type Description latitude Number 纬度 Source: Map.js, line 199 projectToScreen(coords) 经纬度转换屏幕坐标 Parameters: Name Type Description coords Array 经纬度 [lng,lat] Source: Map.js, line 218 Returns: position - 返回距离容器左上角的距离 {x,y} Type Object unprojectFromScreen(pixel) 屏幕坐标转转经纬度 Parameters: Name Type Description pixel Object 屏幕坐标 {x,y} Source: Map.js, line 239 Returns: lnglat - [lng,lat] Type Array unprojectFromWorld(xyz) 世界坐标转经纬度 Parameters: Name Type Description xyz Object 世界坐标 {x,y,z} Source: Map.js, line 258 Returns: lnglat - [lng,lat] Type Array addAtCoordinate(obj, Array, options) 添加物体到3d空间 Parameters: Name Type Description obj Object Three.js的mesh Array lnglat 物体的经纬度 {lng,lat} options Object 配置 Properties Name Type Description scaleToLatitude Boolean 是否按照1px = 1m的比例进行缩放 默认true preScale Number 改变像素到米的换算比例 默认1 Source: Map.js, line 285 Returns: obj -物体mesh Type Object moveToCoordinate(obj, Array, options) 移动3d空间的物体 Parameters: Name Type Description obj Object Three.js的mesh Array lnglat 物体的经纬度 {lng,lat} options Object 配置 Properties Name Type Description scaleToLatitude Boolean 是否按照1px = 1m的比例进行缩放 默认true preScale Number 改变像素到米的换算比例 默认1 Source: Map.js, line 306 Returns: obj - 物体mesh Type Object addGround() 添加默认地面 Source: Map.js, line 355 getDataLayer() Source: Map.js, line 367 remove(obj) 移除物体mesh Parameters: Name Type Description obj Object mesh Source: Map.js, line 377 setupDefaultLights() 设置默认光源 Source: Map.js, line 384 × Search results Close "},"CameraControl.html":{"id":"CameraControl.html","title":"Class: CameraControl","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: CameraControl CameraControl new CameraControl(map, camera, world) 相机控制类 Parameters: Name Type Description map object 包含位置信息的地图对象 camera object 相机对象 world object 世界对象 Source: Camera/CameraControl.js, line 11 Methods listenMapChange() 监听地图瓦片层的变化，并同步执行updateCamera()同步相机 Source: Camera/CameraControl.js, line 47 initMapTransform() 重新初始化没有地图瓦片层时的位置参数 Source: Camera/CameraControl.js, line 64 lngX() 计算地图中心的x值 Source: Camera/CameraControl.js, line 80 latY() 计算地图中心的y值 Source: Camera/CameraControl.js, line 86 getWorldSize() 获取地图应该被放大到的尺寸 Source: Camera/CameraControl.js, line 94 getScale(zoom) 获取地图放大倍数 Parameters: Name Type Description zoom number 地图zoom Source: Camera/CameraControl.js, line 102 setCenter(center) 设置地图中心 Parameters: Name Type Description center Array [lng,lat] Source: Camera/CameraControl.js, line 110 setRotation(deg) 设置旋转角度 Parameters: Name Type Description deg number 旋转的角度（！不是弧度） Source: Camera/CameraControl.js, line 126 setPitch(deg) 设置旋转的俯角 Parameters: Name Type Description deg number 俯视的角度 Source: Camera/CameraControl.js, line 142 updateCamera() 更新相机位置，当map位置信息变化时执行 Source: Camera/CameraControl.js, line 158 updateMap() 更新地图参数，当this.map的参数发生变化时，需要执行该函数同步变化 Source: Camera/CameraControl.js, line 31 × Search results Close "},"Layer.html":{"id":"Layer.html","title":"Class: Layer","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: Layer Layer 图层基础类 new Layer(config) Layer类的构造函数，会把所有用户参数挂到layer对象上 Parameters: Name Type Description config object 用户构造函数配置 Source: Layers/Layer.js, line 6 Methods on() 事件监听,用法同jQuery.on Source: Layers/Layer.js, line 24 fire() 触发事件 Source: Layers/Layer.js, line 40 Example this.fire(&quot;change&quot;,event) off() 关闭事件 Source: Layers/Layer.js, line 57 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Source: Layers/Layer.js, line 81 update() 地图每帧调用该函数 Source: Layers/Layer.js, line 88 onRemove() 移除图层时调用 Source: Layers/Layer.js, line 95 × Search results Close "},"MapControl.html":{"id":"MapControl.html","title":"Class: MapControl","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: MapControl MapControl 地图控制类 new MapControl(config) 构造函数 Parameters: Name Type Description config Object config Properties Name Type Description moveSpeed number 移动速度 pitchSpeed number 角度改变速度 rotateSpeed number 旋转速度 Source: Layers/MapControl.js, line 8 Extends Layer Methods listenEvents() 监听事件 Source: Layers/MapControl.js, line 54 removeListenr() 移除所有监听事件 Source: Layers/MapControl.js, line 149 on() 事件监听,用法同jQuery.on Inherited From: Layer#on Source: Layers/Layer.js, line 24 fire() 触发事件 Inherited From: Layer#fire Source: Layers/Layer.js, line 40 Example this.fire(&quot;change&quot;,event) off() 关闭事件 Inherited From: Layer#off Source: Layers/Layer.js, line 57 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Inherited From: Layer#onAdd Overrides: Layer#onAdd Source: Layers/Layer.js, line 81 update() 地图每帧调用该函数 Inherited From: Layer#update Source: Layers/Layer.js, line 88 onRemove() 移除图层时调用 Inherited From: Layer#onRemove Source: Layers/Layer.js, line 95 Events move 地图移动 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 86 rotate 地图旋转 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 102 zoom 地图缩放 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 120 change 地图状态发生改变，发生操作时触发 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 127 × Search results Close "},"TextLayer.html":{"id":"TextLayer.html","title":"Class: TextLayer","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: TextLayer TextLayer 文字图层类 new TextLayer() Source: Layers/TextLayer.js, line 7 Extends Layer Methods addText() Source: Layers/TextLayer.js, line 73 removeText() 删除某个ID的文字 Source: Layers/TextLayer.js, line 122 getText() 获取某个文字对象 Source: Layers/TextLayer.js, line 147 getTextIndex() 获取某个文字对象的索引 Source: Layers/TextLayer.js, line 163 on() 事件监听,用法同jQuery.on Inherited From: Layer#on Source: Layers/Layer.js, line 24 fire() 触发事件 Inherited From: Layer#fire Source: Layers/Layer.js, line 40 Example this.fire(&quot;change&quot;,event) off() 关闭事件 Inherited From: Layer#off Source: Layers/Layer.js, line 57 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Inherited From: Layer#onAdd Overrides: Layer#onAdd Source: Layers/Layer.js, line 81 update() 地图每帧调用该函数 Inherited From: Layer#update Overrides: Layer#update Source: Layers/Layer.js, line 88 onRemove() 移除图层时调用 Inherited From: Layer#onRemove Overrides: Layer#onRemove Source: Layers/Layer.js, line 95 × Search results Close "},"ThirdPersonLayer.html":{"id":"ThirdPersonLayer.html","title":"Class: ThirdPersonLayer","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: ThirdPersonLayer ThirdPersonLayer 第三人称视角图层 new ThirdPersonLayer(target, viewRotation, targetRotation) 构造函数 Parameters: Name Type Description target Object 需要摄像机跟随的物体 viewRotation Number 观看视角（deg） targetRotation Number 物体初始旋转角度，用来配合摄像机位置 (deg) Source: Layers/ThirdPersonView.js, line 7 Extends Layer Methods updateCamera() 更新相机，物体移动后需要更新相机，重新计算相机位置 Source: Layers/ThirdPersonView.js, line 48 on() 事件监听,用法同jQuery.on Inherited From: Layer#on Source: Layers/Layer.js, line 24 fire() 触发事件 Inherited From: Layer#fire Source: Layers/Layer.js, line 40 Example this.fire(&quot;change&quot;,event) off() 关闭事件 Inherited From: Layer#off Source: Layers/Layer.js, line 57 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Inherited From: Layer#onAdd Overrides: Layer#onAdd Source: Layers/Layer.js, line 81 update() 地图每帧调用该函数 Inherited From: Layer#update Overrides: Layer#update Source: Layers/Layer.js, line 88 onRemove() 移除图层时调用 Inherited From: Layer#onRemove Source: Layers/Layer.js, line 95 × Search results Close "},"MTLLoader.html":{"id":"MTLLoader.html","title":"Class: MTLLoader","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: MTLLoader MTLLoader new MTLLoader() Loads a Wavefront .mtl file specifying materials Author: angelxuanchang Source: Loaders/MTLLoader.js, line 6 Methods load(url [, onLoad] [, onProgress] [, onError]) Loads and parses a MTL asset from a URL. Parameters: Name Type Argument Description url String URL to the MTL file. onLoad function &lt;optional&gt; Callback invoked with the loaded object. onProgress function &lt;optional&gt; Callback for download progress. onError function &lt;optional&gt; Callback for download errors. Source: Loaders/MTLLoader.js, line 29 See: setPath setTexturePath setPath(path) Set base path for resolving references. If set this path will be prepended to each loaded and found reference. Parameters: Name Type Description path String Source: Loaders/MTLLoader.js, line 54 See: setTexturePath Example mtlLoader.setPath( 'assets/obj/' ); mtlLoader.load( 'my.mtl', ... ); setTexturePath(path) Set base path for resolving texture references. If set this path will be prepended found texture reference. If not set and setPath is, it will be used as texture base path. Parameters: Name Type Description path String Source: Loaders/MTLLoader.js, line 73 See: setPath Example mtlLoader.setPath( 'assets/obj/' ); mtlLoader.setTexturePath( 'assets/textures/' ); mtlLoader.load( 'my.mtl', ... ); parse(text) Parses a MTL file. Parameters: Name Type Description text String Content of MTL file Source: Loaders/MTLLoader.js, line 110 See: setPath setTexturePath Returns: Type THREE.MTLLoader.MaterialCreator &lt;static&gt; MaterialCreator(baseUrl, options) Create a new THREE-MTLLoader.MaterialCreator Parameters: Name Type Description baseUrl Url relative to which textures are loaded options Set of options on how to construct the materials side: Which side to apply the material THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide wrap: What type of wrapping to apply for textures THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 Default: false, assumed to be already normalized ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's Default: false Source: Loaders/MTLLoader.js, line 185 × Search results Close "},"OBJLoader.html":{"id":"OBJLoader.html","title":"Class: OBJLoader","body":" PigeonGL Classes MapCameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoader Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global PigeonGL Class: OBJLoader OBJLoader new OBJLoader() Author: mrdoob / http://mrdoob.com/ Source: Loaders/OBJLoader.js, line 5 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
