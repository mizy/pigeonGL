<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Camera_CameraControl.js.html":{"id":"Camera_CameraControl.js.html","title":"Source: Camera/CameraControl.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Camera/CameraControl.js let PigeonGLConstants = require(\"../constants.js\"); let utils = require(\"../Utils/Utils.js\"); /** * 相机控制类 * @class * @param {object} map - 包含位置信息的地图对象 * @param {object} camera - 相机对象 * @param {object} world - 世界对象 */ class CameraControl { constructor(map) { this.scope = map; this.map = map.map; this.camera = map.camera; this.active = true; this.world = map.world || new THREE.Group(); this.world.position.x = this.world.position.y = 0; this.camera.matrixAutoUpdate = false; this.update(); } /** * 更新地图参数，当this.map的参数发生变化时，需要执行该函数同步变化 */ update(map) { this.map = Object.assign(this.map, map); this.initMapTransform(); this.updateCamera(); } /** * 监听地图瓦片层的变化，并同步执行updateCamera()同步相机 */ listenMapChange() { //更新地图对象 this.update(this.map); } /** * 重新初始化没有地图瓦片层时的位置参数 */ initMapTransform() { let transform = {}; transform.width = this.map.width; transform.height = this.map.height; transform.zHeight = this.map.zHeight || 0; //z轴凸起高度 transform.x = this.map.center[0]; transform.y = this.map.center[1]; transform.z = this.map.center[2] || this.getZ(this.map.zoom); transform._pitch = (this.map.pitch * Math.PI) / 180 || 0; transform.angle = (this.map.rotation * Math.PI) / 180 || 0; this.map.transform = transform; } /** * 获取地图放大倍数 * @param {number} zoom - 地图zoom */ getZ(zoom) { return zoom } /** * 设置地图中心 * @param {Array} center - [lng,lat] */ setCenter(center) { this.map.center = center; this.initMapTransform(); } /** * 设置旋转角度 * @param {number} deg - 旋转的角度（！不是弧度） */ setRotation(rad) { this.map.rotation = rad; this.map.transform.angle = (this.map.rotation * Math.PI) / 180; } /** * 设置旋转的俯角 * @param {number} deg - 俯视的角度 */ setPitch(rad) { this.map.pitch = rad; this.map.transform._pitch = (this.map.pitch * Math.PI) / 180; } /** * 更新相机位置，当map位置信息变化时执行 */ updateCamera(ev) { let height = Math.abs(this.map.transform.z) + this.map.transform.zHeight; const fov = this.map.fov || 0.6435011087932844; //*2/Math.pow(this.map.zoom,2); let cameraToCenterDistance = height; const halfFov = fov / 2; const groundAngle = Math.PI / 2 + this.map.transform._pitch; const topHalfSurfaceDistance = (Math.sin(halfFov) * cameraToCenterDistance) / Math.sin(Math.PI - groundAngle - halfFov); const furthestDistance = Math.cos(Math.PI / 2 - this.map.transform._pitch) * topHalfSurfaceDistance + cameraToCenterDistance; const farZ = furthestDistance * 1.01; this.camera.projectionMatrix = utils.makePerspectiveMatrix( fov, this.map.transform.width / this.map.transform.height, 1, farZ ); let cameraWorldMatrix = new THREE.Matrix4(); let cameraTranslateZ = new THREE.Matrix4().makeTranslation(0, 0, height); let cameraRotateX = new THREE.Matrix4().makeRotationX(this.map.transform._pitch); let cameraRotateZ = new THREE.Matrix4().makeRotationZ(this.map.transform.angle); cameraWorldMatrix .premultiply(cameraTranslateZ) .premultiply(cameraRotateX) .premultiply(cameraRotateZ); this.camera.matrixWorld.copy(cameraWorldMatrix); // this.camera.position.z = height; // this.camera.rotation.x = (this.map.transform._pitch); // this.camera.rotation.z = (this.map.transform.angle); // this.camera.rotateOnWorldAxis(new THREE.Vector3(1,0,0),this.map.transform._pitch); // this.camera.rotateOnWorldAxis ( new THREE.Vector3(0,0,1), this.map.transform.angle ) //把整个地图挪到原点 this.world.position.x = -this.map.transform.x; this.world.position.y = -this.map.transform.y; } } export default CameraControl; × Search results Close "},"Layers_Layer.js.html":{"id":"Layers_Layer.js.html","title":"Source: Layers/Layer.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Layers/Layer.js /** * 图层基础类 * @class */ class Layer { layers = [] /** * Layer类的构造函数，会把所有用户参数挂到layer对象上 * @param {object} config - 用户构造函数配置 */ constructor(config) { var _this = this; this._userConfig = config; for (var x in config) { this[x] = config[x] } } /** * 事件监听,用法同jQuery.on */ on(type, listener) { if (this._listeners === undefined) this._listeners = {}; var listeners = this._listeners; if (listeners[type] === undefined) { listeners[type] = []; } if (listeners[type].indexOf(listener) === - 1) { listeners[type].push(listener); } } /** * 触发事件 * @example * this.fire(\"change\",event) */ fire(type, event) { if (this._listeners === undefined) return; var listeners = this._listeners; var listenerArray = listeners[type]; if (listenerArray !== undefined) { var array = listenerArray.slice(0); for (var i = 0, l = array.length; i &lt; l; i++) { array[i].call(this, event); } } } /** * 关闭事件 * @example * this.off('change',onChange) */ off(type, listener) { if (this._listeners === undefined) return; var listeners = this._listeners; var listenerArray = listeners[type]; if (listenerArray !== undefined) { if (listener) { var index = listenerArray.indexOf(listener); if (index !== - 1) { listenerArray.splice(index, 1); } } else { this._listeners[type] = []; } } } initConfig(config) { } /** * 地图添加图层时调用,由子类实现 * @param {Map} map - PigeonGL.Map实例 */ onAdd(map) { this.pigeonMap = map; } /** * 地图每帧调用该函数 */ update() { } /** * 移除图层时调用 */ onRemove() { if (this._listeners) { this._listeners = [] } } /** * 添加图层 * @param {Layer} layer - 图层 */ addLayer(layer) { layer.id = ++this._layerid; this.layers.push(layer); layer.onAdd(this); //初始化layer } /** * 删除图层 * @param {Layer} layer - 图层 */ removeLayer(layer) { for (let x in this.layers) { if (this.layers[x].id == layer.id) { this.layers[x].onRemove(); this.layers.splice(x, 1); return; } } } /** * 获取图层通过id */ getLayerById(id) { for (let i = 0; i &lt; this.layers.length; i++) { if (this.layer.id === id) return layer; } } } export default Layer; × Search results Close "},"Layers_MapControl.js.html":{"id":"Layers_MapControl.js.html","title":"Source: Layers/MapControl.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Layers/MapControl.js import Layer from './Layer.js'; /** * 地图控制类 * @class * @extends Layer */ class MapControl extends Layer { defaultParams = { zoomBase: 600, moveSpeed: 1, pitchSpeed: 0.1, rotateSpeed: 0.15, } /** * 构造函数 * @param {Object} config - config * @param {number} config.moveSpeed - 移动速度 * @param {number} config.pitchSpeed - 角度改变速度 * @param {number} config.rotateSpeed - 旋转速度 */ constructor(config) { super(config); for (var x in this.defaultParams) { if (typeof (this[x]) == \"undefined\") { this[x] = this.defaultParams[x]; } } } onAdd(map) { var _this = this; this.pigeonMap = map; this.map = this.pigeonMap.map;//用户配置或真实地图 this.cameraControl = this.pigeonMap.cameraControl; this.initConfig(); this.listenEvents(); //添加相机更新函数 this.on(\"change\", function () { _this.pigeonMap.fire(\"change\") _this.cameraControl.update();//更新用户参数为相机参数 }) } initConfig() { }; /** * 监听事件 */ listenEvents() { this.onDown = (event) =&gt; { if (event.button == 0) {//左键 this.mouseStatus = 'left' } else if (event.button == 2) {//右键 this.mouseStatus = 'right' } this.mouseDownPosition = { x: event.clientX, y: event.clientY } this.map.container.addEventListener('mousemove', this.onMove) } this.onUp = (event) =&gt; { this.mouseStatus = false; this.map.container.removeEventListener('mousemove', this.onMove) } this.onMove = (event) =&gt; { if (!this.mouseStatus) { return; } if (this.mouseStatus == 'left') { let yDis = event.clientY - this.mouseDownPosition.y; let xDis = event.clientX - this.mouseDownPosition.x; let distance = Math.sqrt(Math.pow(xDis, 2) + Math.pow(yDis, 2)); if (distance &lt; 0.1) return false; let rotation = (xDis &gt; 0 ? -1 : 1) * Math.asin(yDis / distance) + this.map.transform.angle; let ratio = this.moveSpeed * (this.map.zoom / (this.zoomBase + this.map.zoom)); this.map.center[0] += (xDis &gt; 0 ? -1 : 1) * (distance * Math.cos(rotation)) * ratio; this.map.center[1] += (xDis &gt; 0 ? -1 : 1) * (distance * Math.sin(rotation)) * ratio; this.cameraControl.update(); /** * 地图移动 * @event MapControl#move * @property {Object} event */ this.fire(\"move\", event)//地图移动 this.fire(\"change\", event) } else if (this.mouseStatus == 'right') { this.map.pitch += this.pitchSpeed * (event.clientY - this.mouseDownPosition.y); if (this.map.pitch &gt; 90) { this.map.pitch = 90; } else if (this.map.pitch &lt; 0) { this.map.pitch = 0; } this.map.rotation -= this.rotateSpeed * (event.clientX - this.mouseDownPosition.x); this.cameraControl.update(); /** * 地图旋转 * @event MapControl#rotate * @property {Object} event */ this.fire(\"rotate\", event)//地图x旋转 this.fire(\"change\", event) } this.mouseDownPosition = { x: event.clientX, y: event.clientY } } this.onWheel = (event) =&gt; { this.map.zoom -= event.deltaY * this.map.zoom / this.zoomBase; if (this.map.zoom &lt; 5) return this.map.zoom = 5; this.cameraControl.update(); event.preventDefault(); /** * 地图缩放 * @event MapControl#zoom * @property {Object} event - 原生event对象 */ this.fire(\"zoom\", event)//地图缩放 /** * 地图状态发生改变，发生操作时触发 * @event MapControl#change * @property {Object} event - 原生event对象 */ this.fire(\"change\", event) } this.onContextmenu = function onContextmenu(e) { e.preventDefault(); e.stopPropagation(); } this.map.container.addEventListener('mousedown', this.onDown) this.map.container.addEventListener('mouseup', this.onUp) this.map.container.addEventListener('mousemove', this.onMove) this.map.container.addEventListener('wheel', this.onWheel) this.map.container.addEventListener('contextmenu', this.onContextmenu) }; /** * 移除所有监听事件 */ removeListenr() { this.map.container.removeEventListener('mousedown', this.onDown) this.map.container.removeEventListener('mouseup', this.onUp) this.map.container.removeEventListener('mousemove', this.onMove) this.map.container.removeEventListener('wheel', this.onWheel) this.map.container.removeEventListener('contextmenu', this.onContextmenu) } } export default MapControl; × Search results Close "},"Layers_TextLayer.js.html":{"id":"Layers_TextLayer.js.html","title":"Source: Layers/TextLayer.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Layers/TextLayer.js import Layer from './Layer.js'; /** * 文字图层类 * @extends Layer */ class TextLayer extends Layer { defaultParams = { fontSize: '14px', color: '#000000', canvasRender: false } texts = []; textId = 0; constructor(config) { super(config); for (var x in this.defaultParams) { if (typeof (this[x]) == \"undefined\") { this[x] = this.defaultParams[x]; } } }; //图层添加之后的处理函数 onAdd(map) { this.pigeonMap = map; if (!this.canvasRender) { this.initDom(); } else { this.initCanvas(); } var _this = this; function change() { _this.updateText() } this.change = change; this.pigeonMap.on(\"change\", change) } initDom() { this.container = this.pigeonMap.map.container; var div = document.createElement('div'); div.id = 'text_layer_' + this.id; div.className = 'pigeonGL-text-layer'; div.setAttribute(\"width\", this.pigeonMap.map.width); div.setAttribute(\"height\", this.pigeonMap.map.height); div.style.position = 'absolute'; div.style.top = '0'; div.style.left = '0'; div.style.zIndex = ++this.pigeonMap.zIndex; this.dom = div; this.container.appendChild(div); } initCanvas() { this.container = this.pigeonMap.map.container; var canvas = document.createElement('canvas'); canvas.id = 'text_layer_' + this.id; this.container.appendChild(canvas); canvas.setAttribute(\"width\", this.pigeonMap.map.width); canvas.setAttribute(\"height\", this.pigeonMap.map.height); canvas.style.position = 'absolute'; canvas.style.top = '0'; canvas.style.left = '0'; canvas.style.zIndex = ++this.pigeonMap.zIndex; this.canvas = canvas; } /** * @params {color,text,lnglat,fontSize} */ addText(options) { options = Object.assign({}, options) options.id = options.id || ('_text_' + this.textId++); this.texts.push(options); return options; } drawText() { if (!this.canvasRender) { this.drawDomText(); } else { this.drawCanvasText(); } } drawDomText() { this.dom.innerHTML = '';//清空 for (var x in this.texts) { let xy = this.pigeonMap.projectToScreen(this.texts[x].lnglat); let span = document.createElement('span'); span.id = this.texts[x].id; span.innerHTML = this.texts[x].text; this.dom.appendChild(span); span.style.position = 'absolute'; span.style.top = xy.y + 'px'; span.style.left = xy.x + 'px'; for (var y in this.texts[x].style) { span.style[y] = this.texts[x].style[y] } } } drawCanvasText() { var ctx = this.canvas.getContext(\"2d\"); ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); for (var x in this.texts) { let xy = this.pigeonMap.projectToScreen(this.texts[x].lnglat); ctx.font = this.texts[x].font || this.font; ctx.fillStyle = this.texts[x].color || this.color; ctx.fillText(this.texts[x].text, xy.x, xy.y); } } updateDomText() { let span = this.dom.querySelectorAll('span'); for (var x in this.texts) { let xy = this.pigeonMap.projectToScreen(this.texts[x].lnglat); span[x].style.top = xy.y + 'px'; span[x].style.left = xy.x + 'px'; } } /** * 删除某个ID的文字 */ removeText(id) { for (var x in this.texts) { if (this.texts[x].id == id) { this.texts.splice(x, 1); this.drawText(); return; } } } update() { } updateText() { if (!this.canvasRender) { this.updateDomText(); } else { this.drawCanvasText(); } } /** * 获取某个文字对象 */ getText(id) { for (var x in this.texts) { if (this.texts[x].id == id) { return this.text[x] } } } onRemove() { this.pigeonMap.off('change', this.change)//去除map对该对象的引用 this._listeners = null; } /** * 获取某个文字对象的索引 */ getTextIndex(id) { for (var x in this.texts) { if (this.texts[x].id == id) { return x; } } } }; export default TextLayer; × Search results Close "},"Layers_ThirdPersonView.js.html":{"id":"Layers_ThirdPersonView.js.html","title":"Source: Layers/ThirdPersonView.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Layers/ThirdPersonView.js import Layer from './Layer.js'; /** * 第三人称视角图层 * @extends Layer */ class ThirdPersonLayer extends Layer { defaultParams = { target: null,//跟踪物体 viewRotation: 0,//观看视角 targetRotation: 0,//观看物体默认旋转角度 autoUpdate: false, lockRotation: true,//锁定视角 } /** * 构造函数 * @param {Object} target - 需要摄像机跟随的物体 * @param {Number} viewRotation - 观看视角（deg） * @param {Number} targetRotation - 物体初始旋转角度，用来配合摄像机位置 (deg) */ constructor(config) { super(config); for (var x in this.defaultParams) { if (typeof (this[x]) == \"undefined\") { this[x] = this.defaultParams[x]; } } }; //图层添加之后的处理函数 onAdd(map) { this.pigeonMap = map; this.initCamera(); } initCamera() { } update() { if (this.autoUpdate) this.updateCamera(); } /** * 更新相机，物体移动后需要更新相机，重新计算相机位置 */ updateCamera(rotation) { if (!this.target) return false; let lnglat = this.target.coordinates; if (this.lockRotation) { if (!rotation) rotation = this.target.rotation.z * 180 / Math.PI + this.targetRotation + this.viewRotation this.pigeonMap.cameraControl.setRotation(rotation); } this.pigeonMap.cameraControl.setCenter(lnglat); this.pigeonMap.cameraControl.updateCamera(); } }; export default ThirdPersonLayer; × Search results Close "},"Layers_VRLayer.js.html":{"id":"Layers_VRLayer.js.html","title":"Source: Layers/VRLayer.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Layers/VRLayer.js import Layer from './Layer'; export default class VRLayer extends Layer { noVR = false; vrStatus = 'not suppert VR'; constructor(config) { super(config); //先监听时间，再获取VR this.listenEvents(); this.getVRDisplays(); } /** * 获取vrDevice */ getVRDisplays() { let _this = this; if (navigator.getVRDisplays) { navigator.getVRDisplays().then(function (displays) { if (displays.length &gt; 0) { _this.device = displays[0]; _this.renderer.vr.enabled = true; _this.pigeonMap.renderer.vr.setDevice(_this.device); //初始化frameData _this.frameData = new VRFrameData(); } else { _this.vrStatus = 'noDisplay' console.warn('no vr displays'); } }).catch(function (e) { console.warn('Unable to get VR Displays'); }); } } /** * 监听全局VR事件 */ listenEvents() { let _this = this; window.addEventListener('vrdisplayconnect', function (event) { _this.device = event.display || event.detail.display; _this.status == 'connect'; _this.renderer.vr.enabled = true; _this.fire('connected', _this.device); }, false); window.addEventListener('vrdisplaydisconnect', function (event) { _this.status == 'disconnect' _this.renderer.vr.enabled = false; _this.fire('disconnet', _this.device); }, false); window.addEventListener('vrdisplaypresentchange', function (event) { _this.device = event.display || event.detail.display; _this.fire('statuschange', _this.device); }, false); } /** * 进入VR模式 */ enterVR() { this.device.requestPresent([{ source: this.renderer.domElement }]); } /** * 退出VR */ exitVR() { this.device.exitPresent() } /** * 添加Button */ createButton(button) { let _this = this; if (!button) { button = document.createElement(\"button\"); button.style.position = 'absolute'; button.style.bottom = '20px'; button.style.padding = '12px 6px'; button.style.border = '1px solid #fff'; button.style.borderRadius = '4px'; button.style.background = 'transparent'; button.style.color = '#fff'; button.style.textAlign = 'center'; button.style.opacity = '0.5'; button.style.outline = 'none'; button.style.zIndex = '9999'; button.style.cursor = 'auto'; button.style.left = 'calc(50% - 75px)'; button.style.width = '150px'; button.textContent = 'Enter VR'; document.body.appendChild(button); } button.addEventListener(\"click\", function () { if (_this.device) _this.enterVR(); }) } onAdd(map) { this.pigeonMap = map; this.renderer = map.renderer; this.initVRRenderer(); } initVRRenderer() { let _this = this; } } × Search results Close "},"Layers_cloudPoints.js.html":{"id":"Layers_cloudPoints.js.html","title":"Source: Layers/cloudPoints.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Layers/cloudPoints.js /** * 周边车辆绘制类 * @class */ import Layer from './Layer.js'; class PointsLayer extends Layer { lanePoints = []; constructor(config) { super(config); this.initPoints(); } initPoints() { this.material = new THREE.PointsMaterial({ color: 0xffffff, size: 10 }); this.pointsGeometry = new THREE.BufferGeometry(); this.points = new THREE.Points(this.pointsGeometry, this.material); } onAdd(map) { this.pigeonMap = map; this.pigeonMap.world.add(this.points); } /** * 采用相对坐标，防止抖动 */ drawPoints(data) { this.baseLngLat = data[0]; this.baseXYZ = this.pigeonMap.projectToWorld(this.baseLngLat); let points = [], xyz; let index = []; let colors = []; for (var x in data) { xyz = this.pigeonMap.projectToWorld(data[x]); points.push( xyz.x - this.baseXYZ.x, xyz.y - this.baseXYZ.y, xyz.z - this.baseXYZ.z, ); colors.push(data[x]) index.push(x); } this.points.geometry.addAttribute('position', new THREE.Float32BufferAttribute(points, 3)) this.points.geometry.computeBoundingSphere(); this.points.position.x = this.baseXYZ.x; this.points.position.y = this.baseXYZ.y; this.points.position.z = this.baseXYZ.z; } } export default PointsLayer; × Search results Close "},"Loaders_MTLLoader.js.html":{"id":"Loaders_MTLLoader.js.html","title":"Source: Loaders/MTLLoader.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Loaders/MTLLoader.js /** * Loads a Wavefront .mtl file specifying materials * @class * @author angelxuanchang */ const MTLLoader = function ( manager ) { this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager; }; MTLLoader.prototype = { constructor: MTLLoader, /** * Loads and parses a MTL asset from a URL. * * @param {String} url - URL to the MTL file. * @param {Function} [onLoad] - Callback invoked with the loaded object. * @param {Function} [onProgress] - Callback for download progress. * @param {Function} [onError] - Callback for download errors. * * @see setPath setTexturePath * * @note In order for relative texture references to resolve correctly * you must call setPath and/or setTexturePath explicitly prior to load. */ load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new THREE.FileLoader( this.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { onLoad( scope.parse( text ) ); }, onProgress, onError ); }, /** * Set base path for resolving references. * If set this path will be prepended to each loaded and found reference. * * @see setTexturePath * @param {String} path * * @example * mtlLoader.setPath( 'assets/obj/' ); * mtlLoader.load( 'my.mtl', ... ); */ setPath: function ( path ) { this.path = path; }, /** * Set base path for resolving texture references. * If set this path will be prepended found texture reference. * If not set and setPath is, it will be used as texture base path. * * @see setPath * @param {String} path * * @example * mtlLoader.setPath( 'assets/obj/' ); * mtlLoader.setTexturePath( 'assets/textures/' ); * mtlLoader.load( 'my.mtl', ... ); */ setTexturePath: function ( path ) { this.texturePath = path; }, setBaseUrl: function ( path ) { console.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' ); this.setTexturePath( path ); }, setCrossOrigin: function ( value ) { this.crossOrigin = value; }, setMaterialOptions: function ( value ) { this.materialOptions = value; }, /** * Parses a MTL file. * * @param {String} text - Content of MTL file * @return {THREE.MTLLoader.MaterialCreator} * * @see setPath setTexturePath * * @note In order for relative texture references to resolve correctly * you must call setPath and/or setTexturePath explicitly prior to parse. */ parse: function ( text ) { var lines = text.split( '\\n' ); var info = {}; var delimiter_pattern = /\\s+/; var materialsInfo = {}; for ( var i = 0; i &lt; lines.length; i ++ ) { var line = lines[ i ]; line = line.trim(); if ( line.length === 0 || line.charAt( 0 ) === '#' ) { // Blank line or comment ignore continue; } var pos = line.indexOf( ' ' ); var key = ( pos &gt;= 0 ) ? line.substring( 0, pos ) : line; key = key.toLowerCase(); var value = ( pos &gt;= 0 ) ? line.substring( pos + 1 ) : ''; value = value.trim(); if ( key === 'newmtl' ) { // New material info = { name: value }; materialsInfo[ value ] = info; } else if ( info ) { if ( key === 'ka' || key === 'kd' || key === 'ks' ) { var ss = value.split( delimiter_pattern, 3 ); info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ]; } else { info[ key ] = value; } } } var materialCreator = new MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions ); materialCreator.setCrossOrigin( this.crossOrigin ); materialCreator.setManager( this.manager ); materialCreator.setMaterials( materialsInfo ); return materialCreator; } }; /** * Create a new THREE-MTLLoader.MaterialCreator * @param baseUrl - Url relative to which textures are loaded * @param options - Set of options on how to construct the materials * side: Which side to apply the material * THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide * wrap: What type of wrapping to apply for textures * THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping * normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 * Default: false, assumed to be already normalized * ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's * Default: false */ MTLLoader.MaterialCreator = function ( baseUrl, options ) { this.baseUrl = baseUrl || ''; this.options = options; this.materialsInfo = {}; this.materials = {}; this.materialsArray = []; this.nameLookup = {}; this.side = ( this.options &amp;&amp; this.options.side ) ? this.options.side : THREE.FrontSide; this.wrap = ( this.options &amp;&amp; this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping; }; MTLLoader.MaterialCreator.prototype = { constructor: MTLLoader.MaterialCreator, setCrossOrigin: function ( value ) { this.crossOrigin = value; }, setManager: function ( value ) { this.manager = value; }, setMaterials: function ( materialsInfo ) { this.materialsInfo = this.convert( materialsInfo ); this.materials = {}; this.materialsArray = []; this.nameLookup = {}; }, convert: function ( materialsInfo ) { if ( ! this.options ) return materialsInfo; var converted = {}; for ( var mn in materialsInfo ) { // Convert materials info into normalized form based on options var mat = materialsInfo[ mn ]; var covmat = {}; converted[ mn ] = covmat; for ( var prop in mat ) { var save = true; var value = mat[ prop ]; var lprop = prop.toLowerCase(); switch ( lprop ) { case 'kd': case 'ka': case 'ks': // Diffuse color (color under white light) using RGB values if ( this.options &amp;&amp; this.options.normalizeRGB ) { value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ]; } if ( this.options &amp;&amp; this.options.ignoreZeroRGBs ) { if ( value[ 0 ] === 0 &amp;&amp; value[ 1 ] === 0 &amp;&amp; value[ 2 ] === 0 ) { // ignore save = false; } } break; default: break; } if ( save ) { covmat[ lprop ] = value; } } } return converted; }, preload: function () { for ( var mn in this.materialsInfo ) { this.create( mn ); } }, getIndex: function ( materialName ) { return this.nameLookup[ materialName ]; }, getAsArray: function () { var index = 0; for ( var mn in this.materialsInfo ) { this.materialsArray[ index ] = this.create( mn ); this.nameLookup[ mn ] = index; index ++; } return this.materialsArray; }, create: function ( materialName ) { if ( this.materials[ materialName ] === undefined ) { this.createMaterial_( materialName ); } return this.materials[ materialName ]; }, createMaterial_: function ( materialName ) { // Create material var scope = this; var mat = this.materialsInfo[ materialName ]; var params = { name: materialName, side: this.side }; function resolveURL( baseUrl, url ) { if ( typeof url !== 'string' || url === '' ) return ''; // Absolute URL if ( /^https?:\\/\\//i.test( url ) ) return url; return baseUrl + url; } function setMapForType( mapType, value ) { if ( params[ mapType ] ) return; // Keep the first encountered texture var texParams = scope.getTextureParams( value, params ); var map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) ); map.repeat.copy( texParams.scale ); map.offset.copy( texParams.offset ); map.wrapS = scope.wrap; map.wrapT = scope.wrap; params[ mapType ] = map; } for ( var prop in mat ) { var value = mat[ prop ]; if ( value === '' ) continue; switch ( prop.toLowerCase() ) { // Ns is material specular exponent case 'kd': // Diffuse color (color under white light) using RGB values params.color = new THREE.Color().fromArray( value ); break; case 'ks': // Specular color (color when light is reflected from shiny surface) using RGB values params.specular = new THREE.Color().fromArray( value ); break; case 'map_kd': // Diffuse texture map setMapForType( \"map\", value ); break; case 'map_ks': // Specular map setMapForType( \"specularMap\", value ); break; case 'map_bump': case 'bump': // Bump texture map setMapForType( \"bumpMap\", value ); break; case 'ns': // The specular exponent (defines the focus of the specular highlight) // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000. params.shininess = parseFloat( value ); break; case 'd': if ( value &lt; 1 ) { params.opacity = value; params.transparent = true; } break; case 'Tr': if ( value &gt; 0 ) { params.opacity = 1 - value; params.transparent = true; } break; default: break; } } this.materials[ materialName ] = new THREE.MeshPhongMaterial( params ); return this.materials[ materialName ]; }, getTextureParams: function ( value, matParams ) { var texParams = { scale: new THREE.Vector2( 1, 1 ), offset: new THREE.Vector2( 0, 0 ) }; var items = value.split( /\\s+/ ); var pos; pos = items.indexOf( '-bm' ); if ( pos &gt;= 0 ) { matParams.bumpScale = parseFloat( items[ pos + 1 ] ); items.splice( pos, 2 ); } pos = items.indexOf( '-s' ); if ( pos &gt;= 0 ) { texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) ); items.splice( pos, 4 ); // we expect 3 parameters here! } pos = items.indexOf( '-o' ); if ( pos &gt;= 0 ) { texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) ); items.splice( pos, 4 ); // we expect 3 parameters here! } texParams.url = items.join( ' ' ).trim(); return texParams; }, loadTexture: function ( url, mapping, onLoad, onProgress, onError ) { var texture; var loader = THREE.Loader.Handlers.get( url ); var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager; if ( loader === null ) { loader = new THREE.TextureLoader( manager ); } if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin ); texture = loader.load( url, onLoad, onProgress, onError ); if ( mapping !== undefined ) texture.mapping = mapping; return texture; } }; module.exports = exports = MTLLoader; × Search results Close "},"Loaders_OBJLoader.js.html":{"id":"Loaders_OBJLoader.js.html","title":"Source: Loaders/OBJLoader.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Loaders/OBJLoader.js /** * @class * @author mrdoob / http://mrdoob.com/ */ const OBJLoader = function ( manager ) { this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager; this.materials = null; this.regexp = { // v float float float vertex_pattern : /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/, // vn float float float normal_pattern : /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/, // vt float float uv_pattern : /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/, // f vertex vertex vertex face_vertex : /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/, // f vertex/uv vertex/uv vertex/uv face_vertex_uv : /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/, // f vertex/uv/normal vertex/uv/normal vertex/uv/normal face_vertex_uv_normal : /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/, // f vertex//normal vertex//normal vertex//normal face_vertex_normal : /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/, // o object_name | g group_name object_pattern : /^[og]\\s*(.+)?/, // s boolean smoothing_pattern : /^s\\s+(\\d+|on|off)/, // mtllib file_reference material_library_pattern : /^mtllib /, // usemtl material_name material_use_pattern : /^usemtl / }; }; OBJLoader.prototype = { constructor: OBJLoader, load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new THREE.FileLoader( scope.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { onLoad( scope.parse( text ) ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; }, setMaterials: function ( materials ) { this.materials = materials; }, _createParserState : function () { var state = { objects : [], object : {}, vertices : [], normals : [], uvs : [], materialLibraries : [], startObject: function ( name, fromDeclaration ) { // If the current object (initial from reset) is not from a g/o declaration in the parsed // file. We need to use it for the first parsed g/o to keep things in sync. if ( this.object &amp;&amp; this.object.fromDeclaration === false ) { this.object.name = name; this.object.fromDeclaration = ( fromDeclaration !== false ); return; } var previousMaterial = ( this.object &amp;&amp; typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined ); if ( this.object &amp;&amp; typeof this.object._finalize === 'function' ) { this.object._finalize( true ); } this.object = { name : name || '', fromDeclaration : ( fromDeclaration !== false ), geometry : { vertices : [], normals : [], uvs : [] }, materials : [], smooth : true, startMaterial : function( name, libraries ) { var previous = this._finalize( false ); // New usemtl declaration overwrites an inherited material, except if faces were declared // after the material, then it must be preserved for proper MultiMaterial continuation. if ( previous &amp;&amp; ( previous.inherited || previous.groupCount &lt;= 0 ) ) { this.materials.splice( previous.index, 1 ); } var material = { index : this.materials.length, name : name || '', mtllib : ( Array.isArray( libraries ) &amp;&amp; libraries.length &gt; 0 ? libraries[ libraries.length - 1 ] : '' ), smooth : ( previous !== undefined ? previous.smooth : this.smooth ), groupStart : ( previous !== undefined ? previous.groupEnd : 0 ), groupEnd : -1, groupCount : -1, inherited : false, clone : function( index ) { var cloned = { index : ( typeof index === 'number' ? index : this.index ), name : this.name, mtllib : this.mtllib, smooth : this.smooth, groupStart : 0, groupEnd : -1, groupCount : -1, inherited : false }; cloned.clone = this.clone.bind(cloned); return cloned; } }; this.materials.push( material ); return material; }, currentMaterial : function() { if ( this.materials.length &gt; 0 ) { return this.materials[ this.materials.length - 1 ]; } return undefined; }, _finalize : function( end ) { var lastMultiMaterial = this.currentMaterial(); if ( lastMultiMaterial &amp;&amp; lastMultiMaterial.groupEnd === -1 ) { lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3; lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart; lastMultiMaterial.inherited = false; } // Ignore objects tail materials if no face declarations followed them before a new o/g started. if ( end &amp;&amp; this.materials.length &gt; 1 ) { for ( var mi = this.materials.length - 1; mi &gt;= 0; mi-- ) { if ( this.materials[mi].groupCount &lt;= 0 ) { this.materials.splice( mi, 1 ); } } } // Guarantee at least one empty material, this makes the creation later more straight forward. if ( end &amp;&amp; this.materials.length === 0 ) { this.materials.push({ name : '', smooth : this.smooth }); } return lastMultiMaterial; } }; // Inherit previous objects material. // Spec tells us that a declared material must be set to all objects until a new material is declared. // If a usemtl declaration is encountered while this new object is being parsed, it will // overwrite the inherited material. Exception being that there was already face declarations // to the inherited material, then it will be preserved for proper MultiMaterial continuation. if ( previousMaterial &amp;&amp; previousMaterial.name &amp;&amp; typeof previousMaterial.clone === \"function\" ) { var declared = previousMaterial.clone( 0 ); declared.inherited = true; this.object.materials.push( declared ); } this.objects.push( this.object ); }, finalize : function() { if ( this.object &amp;&amp; typeof this.object._finalize === 'function' ) { this.object._finalize( true ); } }, parseVertexIndex: function ( value, len ) { var index = parseInt( value, 10 ); return ( index &gt;= 0 ? index - 1 : index + len / 3 ) * 3; }, parseNormalIndex: function ( value, len ) { var index = parseInt( value, 10 ); return ( index &gt;= 0 ? index - 1 : index + len / 3 ) * 3; }, parseUVIndex: function ( value, len ) { var index = parseInt( value, 10 ); return ( index &gt;= 0 ? index - 1 : index + len / 2 ) * 2; }, addVertex: function ( a, b, c ) { var src = this.vertices; var dst = this.object.geometry.vertices; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ a + 2 ] ); dst.push( src[ b + 0 ] ); dst.push( src[ b + 1 ] ); dst.push( src[ b + 2 ] ); dst.push( src[ c + 0 ] ); dst.push( src[ c + 1 ] ); dst.push( src[ c + 2 ] ); }, addVertexLine: function ( a ) { var src = this.vertices; var dst = this.object.geometry.vertices; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ a + 2 ] ); }, addNormal : function ( a, b, c ) { var src = this.normals; var dst = this.object.geometry.normals; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ a + 2 ] ); dst.push( src[ b + 0 ] ); dst.push( src[ b + 1 ] ); dst.push( src[ b + 2 ] ); dst.push( src[ c + 0 ] ); dst.push( src[ c + 1 ] ); dst.push( src[ c + 2 ] ); }, addUV: function ( a, b, c ) { var src = this.uvs; var dst = this.object.geometry.uvs; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); dst.push( src[ b + 0 ] ); dst.push( src[ b + 1 ] ); dst.push( src[ c + 0 ] ); dst.push( src[ c + 1 ] ); }, addUVLine: function ( a ) { var src = this.uvs; var dst = this.object.geometry.uvs; dst.push( src[ a + 0 ] ); dst.push( src[ a + 1 ] ); }, addFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) { var vLen = this.vertices.length; var ia = this.parseVertexIndex( a, vLen ); var ib = this.parseVertexIndex( b, vLen ); var ic = this.parseVertexIndex( c, vLen ); var id; if ( d === undefined ) { this.addVertex( ia, ib, ic ); } else { id = this.parseVertexIndex( d, vLen ); this.addVertex( ia, ib, id ); this.addVertex( ib, ic, id ); } if ( ua !== undefined ) { var uvLen = this.uvs.length; ia = this.parseUVIndex( ua, uvLen ); ib = this.parseUVIndex( ub, uvLen ); ic = this.parseUVIndex( uc, uvLen ); if ( d === undefined ) { this.addUV( ia, ib, ic ); } else { id = this.parseUVIndex( ud, uvLen ); this.addUV( ia, ib, id ); this.addUV( ib, ic, id ); } } if ( na !== undefined ) { // Normals are many times the same. If so, skip function call and parseInt. var nLen = this.normals.length; ia = this.parseNormalIndex( na, nLen ); ib = na === nb ? ia : this.parseNormalIndex( nb, nLen ); ic = na === nc ? ia : this.parseNormalIndex( nc, nLen ); if ( d === undefined ) { this.addNormal( ia, ib, ic ); } else { id = this.parseNormalIndex( nd, nLen ); this.addNormal( ia, ib, id ); this.addNormal( ib, ic, id ); } } }, addLineGeometry: function ( vertices, uvs ) { this.object.geometry.type = 'Line'; var vLen = this.vertices.length; var uvLen = this.uvs.length; for ( var vi = 0, l = vertices.length; vi &lt; l; vi ++ ) { this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) ); } for ( var uvi = 0, l = uvs.length; uvi &lt; l; uvi ++ ) { this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) ); } } }; state.startObject( '', false ); return state; }, parse: function ( text ) { //console.time( 'OBJLoader' ); var state = this._createParserState(); if ( text.indexOf( '\\r\\n' ) !== - 1 ) { // This is faster than String.split with regex that splits on both text = text.replace( /\\r\\n/g, '\\n' ); } if ( text.indexOf( '\\\\\\n' ) !== - 1) { // join lines separated by a line continuation character (\\) text = text.replace( /\\\\\\n/g, '' ); } var lines = text.split( '\\n' ); var line = '', lineFirstChar = '', lineSecondChar = ''; var lineLength = 0; var result = []; // Faster to just trim left side of the line. Use if available. var trimLeft = ( typeof ''.trimLeft === 'function' ); for ( var i = 0, l = lines.length; i &lt; l; i ++ ) { line = lines[ i ]; line = trimLeft ? line.trimLeft() : line.trim(); lineLength = line.length; if ( lineLength === 0 ) continue; lineFirstChar = line.charAt( 0 ); // @todo invoke passed in handler if any if ( lineFirstChar === '#' ) continue; if ( lineFirstChar === 'v' ) { lineSecondChar = line.charAt( 1 ); if ( lineSecondChar === ' ' &amp;&amp; ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) { // 0 1 2 3 // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"] state.vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) ); } else if ( lineSecondChar === 'n' &amp;&amp; ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) { // 0 1 2 3 // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"] state.normals.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) ); } else if ( lineSecondChar === 't' &amp;&amp; ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) { // 0 1 2 // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"] state.uvs.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ) ); } else { throw new Error( \"Unexpected vertex/normal/uv line: '\" + line + \"'\" ); } } else if ( lineFirstChar === \"f\" ) { if ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) { // f vertex/uv/normal vertex/uv/normal vertex/uv/normal // 0 1 2 3 4 5 6 7 8 9 10 11 12 // [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined] state.addFace( result[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ], result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ], result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ); } else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) { // f vertex/uv vertex/uv vertex/uv // 0 1 2 3 4 5 6 7 8 // [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined] state.addFace( result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ], result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ] ); } else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) { // f vertex//normal vertex//normal vertex//normal // 0 1 2 3 4 5 6 7 8 // [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined] state.addFace( result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ], undefined, undefined, undefined, undefined, result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ] ); } else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) { // f vertex vertex vertex // 0 1 2 3 4 // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined] state.addFace( result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ); } else { throw new Error( \"Unexpected face line: '\" + line + \"'\" ); } } else if ( lineFirstChar === \"l\" ) { var lineParts = line.substring( 1 ).trim().split( \" \" ); var lineVertices = [], lineUVs = []; if ( line.indexOf( \"/\" ) === - 1 ) { lineVertices = lineParts; } else { for ( var li = 0, llen = lineParts.length; li &lt; llen; li ++ ) { var parts = lineParts[ li ].split( \"/\" ); if ( parts[ 0 ] !== \"\" ) lineVertices.push( parts[ 0 ] ); if ( parts[ 1 ] !== \"\" ) lineUVs.push( parts[ 1 ] ); } } state.addLineGeometry( lineVertices, lineUVs ); } else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) { // o object_name // or // g group_name // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869 // var name = result[ 0 ].substr( 1 ).trim(); var name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 ); state.startObject( name ); } else if ( this.regexp.material_use_pattern.test( line ) ) { // material state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries ); } else if ( this.regexp.material_library_pattern.test( line ) ) { // mtl file state.materialLibraries.push( line.substring( 7 ).trim() ); } else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) { // smooth shading // @todo Handle files that have varying smooth values for a set of faces inside one geometry, // but does not define a usemtl for each face set. // This should be detected and a dummy material created (later MultiMaterial and geometry groups). // This requires some care to not create extra material on each smooth value for \"normal\" obj files. // where explicit usemtl defines geometry groups. // Example asset: examples/models/obj/cerberus/Cerberus.obj var value = result[ 1 ].trim().toLowerCase(); state.object.smooth = ( value === '1' || value === 'on' ); var material = state.object.currentMaterial(); if ( material ) { material.smooth = state.object.smooth; } } else { // Handle null terminated files without exception if ( line === '\\0' ) continue; throw new Error( \"Unexpected line: '\" + line + \"'\" ); } } state.finalize(); var container = new THREE.Group(); container.materialLibraries = [].concat( state.materialLibraries ); for ( var i = 0, l = state.objects.length; i &lt; l; i ++ ) { var object = state.objects[ i ]; var geometry = object.geometry; var materials = object.materials; var isLine = ( geometry.type === 'Line' ); // Skip o/g line declarations that did not follow with any faces if ( geometry.vertices.length === 0 ) continue; var buffergeometry = new THREE.BufferGeometry(); buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) ); if ( geometry.normals.length &gt; 0 ) { buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) ); } else { buffergeometry.computeVertexNormals(); } if ( geometry.uvs.length &gt; 0 ) { buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) ); } // Create materials var createdMaterials = []; for ( var mi = 0, miLen = materials.length; mi &lt; miLen ; mi++ ) { var sourceMaterial = materials[mi]; var material = undefined; if ( this.materials !== null ) { material = this.materials.create( sourceMaterial.name ); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material. if ( isLine &amp;&amp; material &amp;&amp; ! ( material instanceof THREE.LineBasicMaterial ) ) { var materialLine = new THREE.LineBasicMaterial(); materialLine.copy( material ); materialLine.lights = false; material = materialLine; } } if ( ! material ) { material = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() ); material.name = sourceMaterial.name; } material.flatShading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading; createdMaterials.push(material); } // Create mesh var mesh; if ( createdMaterials.length &gt; 1 ) { for ( var mi = 0, miLen = materials.length; mi &lt; miLen ; mi++ ) { var sourceMaterial = materials[mi]; buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi ); } var multiMaterial = new THREE.MultiMaterial( createdMaterials ); mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, multiMaterial ) : new THREE.LineSegments( buffergeometry, multiMaterial ) ); } else { mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) ); } mesh.name = object.name; container.add( mesh ); } //console.timeEnd( 'OBJLoader' ); return container; } }; module.exports = exports = OBJLoader; × Search results Close "},"Map.js.html":{"id":"Map.js.html","title":"Source: Map.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: Map.js let PigeonGLConstants = require(\"./constants.js\"); import CameraControl from \"./Camera/CameraControl.js\"; import Layer from \"./Layers/Layer.js\"; /** * 信鸽地图地图核心类，用于生成3d空间地图底层 */ class Map extends Layer { _layerid = 0; zIndex = 1000; status = \"running\"; type = \"gps\"; layers = []; /** * 地图构造函数 * @constructor * @param {Object} map - 地图绘制对象,目前支持高德,mapbox或者纯空间 * @param {Number} map.width - 地图宽度, default:1000 * @param {Number} map.height - 地图高度, default:600 * @param {Number} map.rotation - 地图旋转角度, default:60 * @param {Number} map.pitch - 地图俯视角度, default:45 * @param {Array} map.center - 地图默认中心位置经纬度, default:[0,0] * @param {Number} map.zoom - 地图缩放级别,default:21 * @param {dom} map.container - 容器dom */ constructor(map) { super(); this.clock = new THREE.Clock(); this.clock.start(); this.initMap(map); this.initWorld(); if (this.map.hasGround) { this.addGround(); } this.update(); } initMap(map) { this.map = Object.assign( { rotation: 0, width: 1000, height: 600, pitch: 45, zoom: 21, center: [0, 0] }, map ); } initWorld() { // Set up a THREE.js scene this.renderer = new THREE.WebGLRenderer( Object.assign({ alpha: true, antialias: true }, this.map.rendererOptions) ); this.renderer.setSize(this.map.width, this.map.height); this.map.container.appendChild(this.renderer.domElement); this.renderer.domElement.style[\"position\"] = \"relative\"; this.renderer.domElement.style[\"pointer-events\"] = \"none\"; this.renderer.domElement.style[\"z-index\"] = ++this.zIndex; /** * @property {Object} scene - this.scene为three.js场景 */ this.scene = new THREE.Scene(Object.assign({}, this.map.sceneOptions || {})); /** * @property {Object} camera - this.camera.js场景 */ this.camera = new THREE.PerspectiveCamera( 45, this.map.width / this.map.height, 0.000001, 5000000000 ); /** * @property {Object} layers - 图层集合 */ this.layers = []; /** * @property {Object} world - this.world为世界模型组，所有模型被添加到该组内 */ this.world = new THREE.Group(); this.scene.add(this.world); this.camera.position.z = 10; this.camera.position.x = this.map.center[0]; this.camera.position.y = this.map.center[1]; /** * @property {CameraControl} cameraControl - 摄像机控制类 */ this.cameraControl = new CameraControl(this); } moveTo(obj, coord, options = {}) { let scale = options.preScale; let geoGroup; if (obj.userData.isGeoGroup) geoGroup = obj; else if (obj.parent &amp;&amp; obj.parent.userData.isGeoGroup) geoGroup = obj.parent; geoGroup.scale.copy(scale || 1); geoGroup.position.copy(this.projectToWorld(coord)); obj.coordinates = coord; return obj; } /** * 自动刷新渲染，可以改变this.status=='top',停止自动刷新 * @parma {Number} delta - 每帧时间差，用来保持不同机器动画速度相同,用不到不必搭理 */ update() { let delta = this.clock.getDelta(); //子layer更新 for (let x in this.layers) { if (this.layers[x].update) { this.layers[x].update(delta); } } this.renderer.render(this.scene, this.camera); let device; if ((device = this.renderer.vr.getDevice())) { this.animationframe = device.requestAnimationFrame((timestamp) =&gt; { if (this.status != \"stop\") this.update(delta, timestamp); }); return; } this.animationframe = requestAnimationFrame((timestamp) =&gt; { if (this.status != \"stop\") this.update(delta, timestamp); }); } projectToWorld(coord) { return { x: coord[0], y: coord[1], z: coord[2] || 0 }; } unprojectFromWorld(world) { return [world.x, world.y, world.z]; } /** * 经纬度转换屏幕坐标 * @param {Array} coords - 经纬度 [lng,lat] * @return {Object} position - 返回距离容器左上角的距离 {x,y} */ projectToScreen(param) { let coords = Object.assign({}, param); coords[1] = -coords[1]; let world = this.projectToWorld(coords); let worldPosition = this.world.getWorldPosition().clone(); let standarVector = worldPosition.add(world).project(this.camera); //世界坐标转设备坐标 let a = this.map.width / 2; let b = this.map.height / 2; let x = Math.round(standarVector.x * a + a); //标准设备坐标转屏幕坐标 let y = this.map.height - Math.round(standarVector.y * b + b); //标准设备坐标转屏幕坐标 return { x: x, y: y }; } /** * 屏幕坐标转转经纬度 * @param {Object} pixel - 屏幕坐标 {x,y} * @return {Array} coord - [x,y] */ unprojectFromScreen(pixel) { let a = this.map.width / 2; let b = this.map.height / 2; let standX = -(pixel.x - a) / a; let standY = (this.map.height - pixel.y - b) / b; let standarVector = new THREE.Vector3(standX, standY, 0); let world = standarVector.unproject(this.camera); let worldPosition = this.world.getWorldPosition().clone(); let coord = this.unprojectFromWorld(world.sub(worldPosition)); coord[1] = -coord[1]; return coord; } /** * 添加物体到3d空间 * @param {Object} obj - Three.js的mesh * @param {coord} Array - 物体的经纬度 {lng,lat} * @param {Object} options - 配置 * @param {Boolean} options.scaleToLatitude - 是否按照1px = 1m的比例进行缩放 默认true * @param {Number} options.preScale - 改变像素到米的换算比例 默认1 * @return {Object} obj -物体mesh */ add(obj, coord, options) { let geoGroup = new THREE.Group(); geoGroup.userData.isGeoGroup = true; geoGroup.add(obj); this.world.add(geoGroup); this.moveTo(obj, coord, options); return obj; } /** * 添加默认地面 */ addGround() { let geometry = new THREE.PlaneGeometry( PigeonGLConstants.WORLD_SIZE, PigeonGLConstants.WORLD_SIZE ); let material = new THREE.MeshPhongMaterial({ color: this.map.groundColor || 0x666666, shininess: 30 }); let plane = new THREE.Mesh(geometry, material); // plane.position.x = plane.position.y = - PigeonGLConstants.WORLD_SIZE/2; plane.position.z = -0.01; this.addAtCoordinate(plane, this.map.center, { scaleToLatitude: true, preScale: 100 }); } /** * 移除物体mesh * @param {Object} obj - mesh */ remove(obj) { this.world.remove(obj); } /** * 设置默认光源 */ setupDefaultLights() { this.scene.add(new THREE.AmbientLight(0xcccccc)); let sunlight = new THREE.DirectionalLight(0xffffff, 0.5); sunlight.position.set(0, 800, 1000); sunlight.matrixWorldNeedsUpdate = true; this.world.add(sunlight); } } export default Map; × Search results Close "},"PigeonGL.js.html":{"id":"PigeonGL.js.html","title":"Source: PigeonGL.js","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Source: PigeonGL.js /** * window.PigeonGL * @example * ``` * new PigeonGL.Map() * ``` * @author mizy.mz 17/12/06 * @global * @property {Objcet} MTLLoader - MTL Loaders * @property {Objcet} OBJLoader - OBJ Loaders * @property {Map} Map - Map类，初始化:new PigeonGL.Map() * @property {Layer} Layer - 核心图层基类，不可被实例化， * @property {SymbolLayer3D} SymbolLayer3D - 3d模型图层 * @property {ThirdPersonView} ThirdPersonView - 第三人称视角控制层 * @property {MapControl} MapControl - 地图控制图层 * @property {TextLayer} TextLayer - 文字图层 */ const PigeonGL = { MTLLoader: require(\"./Loaders/MTLLoader.js\"), OBJLoader: require(\"./Loaders/OBJLoader.js\"), //core Map: require(\"./Map.js\").default, Layer: require(\"./Layers/Layer.js\").default, CameraControl: require(\"./Camera/CameraControl.js\").default, //layer ThirdPersonView: require(\"./Layers/ThirdPersonView.js\").default, MapControl: require(\"./Layers/MapControl.js\").default, TextLayer: require(\"./Layers/TextLayer.js\").default, VRLayer: require(\"./Layers/VRLayer.js\").default, CloudPoints: require(\"./Layers/CloudPoints.js\").default } window.PigeonGL = PigeonGL; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Global Members &lt;constant&gt; PigeonGL window.PigeonGL Properties: Name Type Description MTLLoader Objcet MTL Loaders OBJLoader Objcet OBJ Loaders Map Map Map类，初始化:new PigeonGL.Map() Layer Layer 核心图层基类，不可被实例化， SymbolLayer3D SymbolLayer3D 3d模型图层 ThirdPersonView ThirdPersonView 第三人称视角控制层 MapControl MapControl 地图控制图层 TextLayer TextLayer 文字图层 Author: mizy.mz 17/12/06 Source: PigeonGL.js, line 18 Example ``` new PigeonGL.Map() ``` Methods getVRDisplays() 获取vrDevice Source: Layers/VRLayer.js, line 17 listenEvents() 监听全局VR事件 Source: Layers/VRLayer.js, line 40 enterVR() 进入VR模式 Source: Layers/VRLayer.js, line 64 exitVR() 退出VR Source: Layers/VRLayer.js, line 71 createButton() 添加Button Source: Layers/VRLayer.js, line 78 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Classes Classes CameraControl Layer MapControl TextLayer ThirdPersonLayer MTLLoader OBJLoader Map Events move 地图移动 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 85 rotate 地图旋转 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 102 zoom 地图缩放 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 122 change 地图状态发生改变，发生操作时触发 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 129 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL pigeon-gl 3d map by three.js used in auto-drive simulation systerm features GPS &amp; UTM coordinate support demo basic demo utm UTM on mapbox api documention var map = new PigeonGL.Map({ container:document.getElementById(\"map\"), center:[0,0], width:window.innerWidth, height:window.innerHeight, pitch:0, rotation:0, zoom:21 }) //add models map.addAtCoordinate(obj,[0,0]) build npm run build doc npm run doc × Search results Close "},"CameraControl.html":{"id":"CameraControl.html","title":"Class: CameraControl","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: CameraControl CameraControl 相机控制类 new CameraControl(map, camera, world) Parameters: Name Type Description map object 包含位置信息的地图对象 camera object 相机对象 world object 世界对象 Source: Camera/CameraControl.js, line 12 Methods update() 更新地图参数，当this.map的参数发生变化时，需要执行该函数同步变化 Source: Camera/CameraControl.js, line 26 listenMapChange() 监听地图瓦片层的变化，并同步执行updateCamera()同步相机 Source: Camera/CameraControl.js, line 35 initMapTransform() 重新初始化没有地图瓦片层时的位置参数 Source: Camera/CameraControl.js, line 43 getZ(zoom) 获取地图放大倍数 Parameters: Name Type Description zoom number 地图zoom Source: Camera/CameraControl.js, line 61 setCenter(center) 设置地图中心 Parameters: Name Type Description center Array [lng,lat] Source: Camera/CameraControl.js, line 69 setRotation(deg) 设置旋转角度 Parameters: Name Type Description deg number 旋转的角度（！不是弧度） Source: Camera/CameraControl.js, line 78 setPitch(deg) 设置旋转的俯角 Parameters: Name Type Description deg number 俯视的角度 Source: Camera/CameraControl.js, line 87 updateCamera() 更新相机位置，当map位置信息变化时执行 Source: Camera/CameraControl.js, line 95 × Search results Close "},"Layer.html":{"id":"Layer.html","title":"Class: Layer","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: Layer Layer 图层基础类 new Layer(config) Layer类的构造函数，会把所有用户参数挂到layer对象上 Parameters: Name Type Description config object 用户构造函数配置 Source: Layers/Layer.js, line 13 Methods on() 事件监听,用法同jQuery.on Source: Layers/Layer.js, line 25 fire() 触发事件 Source: Layers/Layer.js, line 41 Example this.fire(\"change\",event) off() 关闭事件 Source: Layers/Layer.js, line 58 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Source: Layers/Layer.js, line 82 update() 地图每帧调用该函数 Source: Layers/Layer.js, line 89 onRemove() 移除图层时调用 Source: Layers/Layer.js, line 96 addLayer(layer) 添加图层 Parameters: Name Type Description layer Layer 图层 Source: Layers/Layer.js, line 106 removeLayer(layer) 删除图层 Parameters: Name Type Description layer Layer 图层 Source: Layers/Layer.js, line 116 getLayerById() 获取图层通过id Source: Layers/Layer.js, line 129 × Search results Close "},"MapControl.html":{"id":"MapControl.html","title":"Class: MapControl","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: MapControl MapControl 地图控制类 new MapControl(config) 构造函数 Parameters: Name Type Description config Object config Properties Name Type Description moveSpeed number 移动速度 pitchSpeed number 角度改变速度 rotateSpeed number 旋转速度 Source: Layers/MapControl.js, line 24 Extends Layer Methods listenEvents() 监听事件 Source: Layers/MapControl.js, line 54 removeListenr() 移除所有监听事件 Source: Layers/MapControl.js, line 151 on() 事件监听,用法同jQuery.on Inherited From: Layer#on Overrides: Layer#on Source: Layers/Layer.js, line 25 fire() 触发事件 Inherited From: Layer#fire Overrides: Layer#fire Source: Layers/Layer.js, line 41 Example this.fire(\"change\",event) off() 关闭事件 Inherited From: Layer#off Overrides: Layer#off Source: Layers/Layer.js, line 58 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Inherited From: Layer#onAdd Overrides: Layer#onAdd Source: Layers/Layer.js, line 82 update() 地图每帧调用该函数 Inherited From: Layer#update Overrides: Layer#update Source: Layers/Layer.js, line 89 onRemove() 移除图层时调用 Inherited From: Layer#onRemove Overrides: Layer#onRemove Source: Layers/Layer.js, line 96 addLayer(layer) 添加图层 Parameters: Name Type Description layer Layer 图层 Inherited From: Layer#addLayer Overrides: Layer#addLayer Source: Layers/Layer.js, line 106 removeLayer(layer) 删除图层 Parameters: Name Type Description layer Layer 图层 Inherited From: Layer#removeLayer Overrides: Layer#removeLayer Source: Layers/Layer.js, line 116 getLayerById() 获取图层通过id Inherited From: Layer#getLayerById Overrides: Layer#getLayerById Source: Layers/Layer.js, line 129 Events move 地图移动 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 85 rotate 地图旋转 Properties: Name Type Description event Object Source: Layers/MapControl.js, line 102 zoom 地图缩放 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 122 change 地图状态发生改变，发生操作时触发 Properties: Name Type Description event Object 原生event对象 Source: Layers/MapControl.js, line 129 × Search results Close "},"TextLayer.html":{"id":"TextLayer.html","title":"Class: TextLayer","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: TextLayer TextLayer 文字图层类 new TextLayer() Source: Layers/TextLayer.js, line 15 Extends Layer Methods addText() Source: Layers/TextLayer.js, line 73 removeText() 删除某个ID的文字 Source: Layers/TextLayer.js, line 130 getText() 获取某个文字对象 Source: Layers/TextLayer.js, line 155 getTextIndex() 获取某个文字对象的索引 Source: Layers/TextLayer.js, line 171 on() 事件监听,用法同jQuery.on Inherited From: Layer#on Overrides: Layer#on Source: Layers/Layer.js, line 25 fire() 触发事件 Inherited From: Layer#fire Overrides: Layer#fire Source: Layers/Layer.js, line 41 Example this.fire(\"change\",event) off() 关闭事件 Inherited From: Layer#off Overrides: Layer#off Source: Layers/Layer.js, line 58 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Inherited From: Layer#onAdd Overrides: Layer#onAdd Source: Layers/Layer.js, line 82 update() 地图每帧调用该函数 Inherited From: Layer#update Overrides: Layer#update Source: Layers/Layer.js, line 89 onRemove() 移除图层时调用 Inherited From: Layer#onRemove Overrides: Layer#onRemove Source: Layers/Layer.js, line 96 addLayer(layer) 添加图层 Parameters: Name Type Description layer Layer 图层 Inherited From: Layer#addLayer Overrides: Layer#addLayer Source: Layers/Layer.js, line 106 removeLayer(layer) 删除图层 Parameters: Name Type Description layer Layer 图层 Inherited From: Layer#removeLayer Overrides: Layer#removeLayer Source: Layers/Layer.js, line 116 getLayerById() 获取图层通过id Inherited From: Layer#getLayerById Overrides: Layer#getLayerById Source: Layers/Layer.js, line 129 × Search results Close "},"ThirdPersonLayer.html":{"id":"ThirdPersonLayer.html","title":"Class: ThirdPersonLayer","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: ThirdPersonLayer ThirdPersonLayer 第三人称视角图层 new ThirdPersonLayer(target, viewRotation, targetRotation) 构造函数 Parameters: Name Type Description target Object 需要摄像机跟随的物体 viewRotation Number 观看视角（deg） targetRotation Number 物体初始旋转角度，用来配合摄像机位置 (deg) Source: Layers/ThirdPersonView.js, line 22 Extends Layer Methods updateCamera() 更新相机，物体移动后需要更新相机，重新计算相机位置 Source: Layers/ThirdPersonView.js, line 49 on() 事件监听,用法同jQuery.on Inherited From: Layer#on Overrides: Layer#on Source: Layers/Layer.js, line 25 fire() 触发事件 Inherited From: Layer#fire Overrides: Layer#fire Source: Layers/Layer.js, line 41 Example this.fire(\"change\",event) off() 关闭事件 Inherited From: Layer#off Overrides: Layer#off Source: Layers/Layer.js, line 58 Example this.off('change',onChange) onAdd(map) 地图添加图层时调用,由子类实现 Parameters: Name Type Description map Map PigeonGL.Map实例 Inherited From: Layer#onAdd Overrides: Layer#onAdd Source: Layers/Layer.js, line 82 update() 地图每帧调用该函数 Inherited From: Layer#update Overrides: Layer#update Source: Layers/Layer.js, line 89 onRemove() 移除图层时调用 Inherited From: Layer#onRemove Overrides: Layer#onRemove Source: Layers/Layer.js, line 96 addLayer(layer) 添加图层 Parameters: Name Type Description layer Layer 图层 Inherited From: Layer#addLayer Overrides: Layer#addLayer Source: Layers/Layer.js, line 106 removeLayer(layer) 删除图层 Parameters: Name Type Description layer Layer 图层 Inherited From: Layer#removeLayer Overrides: Layer#removeLayer Source: Layers/Layer.js, line 116 getLayerById() 获取图层通过id Inherited From: Layer#getLayerById Overrides: Layer#getLayerById Source: Layers/Layer.js, line 129 × Search results Close "},"MTLLoader.html":{"id":"MTLLoader.html","title":"Class: MTLLoader","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: MTLLoader MTLLoader new MTLLoader() Loads a Wavefront .mtl file specifying materials Author: angelxuanchang Source: Loaders/MTLLoader.js, line 6 Methods load(url [, onLoad] [, onProgress] [, onError]) Loads and parses a MTL asset from a URL. Parameters: Name Type Argument Description url String URL to the MTL file. onLoad function &lt;optional&gt; Callback invoked with the loaded object. onProgress function &lt;optional&gt; Callback for download progress. onError function &lt;optional&gt; Callback for download errors. Source: Loaders/MTLLoader.js, line 29 See: setPath setTexturePath setPath(path) Set base path for resolving references. If set this path will be prepended to each loaded and found reference. Parameters: Name Type Description path String Source: Loaders/MTLLoader.js, line 54 See: setTexturePath Example mtlLoader.setPath( 'assets/obj/' ); mtlLoader.load( 'my.mtl', ... ); setTexturePath(path) Set base path for resolving texture references. If set this path will be prepended found texture reference. If not set and setPath is, it will be used as texture base path. Parameters: Name Type Description path String Source: Loaders/MTLLoader.js, line 73 See: setPath Example mtlLoader.setPath( 'assets/obj/' ); mtlLoader.setTexturePath( 'assets/textures/' ); mtlLoader.load( 'my.mtl', ... ); parse(text) Parses a MTL file. Parameters: Name Type Description text String Content of MTL file Source: Loaders/MTLLoader.js, line 110 See: setPath setTexturePath Returns: Type THREE.MTLLoader.MaterialCreator &lt;static&gt; MaterialCreator(baseUrl, options) Create a new THREE-MTLLoader.MaterialCreator Parameters: Name Type Description baseUrl Url relative to which textures are loaded options Set of options on how to construct the materials side: Which side to apply the material THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide wrap: What type of wrapping to apply for textures THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 Default: false, assumed to be already normalized ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's Default: false Source: Loaders/MTLLoader.js, line 185 × Search results Close "},"OBJLoader.html":{"id":"OBJLoader.html","title":"Class: OBJLoader","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: OBJLoader OBJLoader new OBJLoader() Author: mrdoob / http://mrdoob.com/ Source: Loaders/OBJLoader.js, line 5 × Search results Close "},"Map.html":{"id":"Map.html","title":"Class: Map","body":" PigeonGL Classes CameraControlLayerMapControlTextLayerThirdPersonLayerMTLLoaderOBJLoaderMap Events MapControl#event:moveMapControl#event:rotateMapControl#event:zoomMapControl#event:change Global getVRDisplayslistenEventsenterVRexitVRcreateButtonPigeonGL Class: Map Map 信鸽地图地图核心类，用于生成3d空间地图底层 new Map(map) 地图构造函数 Parameters: Name Type Description map Object 地图绘制对象,目前支持高德,mapbox或者纯空间 Properties Name Type Description width Number 地图宽度, default:1000 height Number 地图高度, default:600 rotation Number 地图旋转角度, default:60 pitch Number 地图俯视角度, default:45 center Array 地图默认中心位置经纬度, default:[0,0] zoom Number 地图缩放级别,default:21 container dom 容器dom Source: Map.js, line 26 Members scene Properties: Name Type Description scene Object this.scene为three.js场景 Source: Map.js, line 67 camera Properties: Name Type Description camera Object this.camera.js场景 Source: Map.js, line 72 layers Properties: Name Type Description layers Object 图层集合 Source: Map.js, line 82 world Properties: Name Type Description world Object this.world为世界模型组，所有模型被添加到该组内 Source: Map.js, line 87 cameraControl Properties: Name Type Description cameraControl CameraControl 摄像机控制类 Source: Map.js, line 98 Methods update() 自动刷新渲染，可以改变this.status=='top',停止自动刷新 Source: Map.js, line 116 projectToScreen(coords) 经纬度转换屏幕坐标 Parameters: Name Type Description coords Array 经纬度 [lng,lat] Source: Map.js, line 158 Returns: position - 返回距离容器左上角的距离 {x,y} Type Object unprojectFromScreen(pixel) 屏幕坐标转转经纬度 Parameters: Name Type Description pixel Object 屏幕坐标 {x,y} Source: Map.js, line 179 Returns: coord - [x,y] Type Array add(obj, Array, options) 添加物体到3d空间 Parameters: Name Type Description obj Object Three.js的mesh Array coord 物体的经纬度 {lng,lat} options Object 配置 Properties Name Type Description scaleToLatitude Boolean 是否按照1px = 1m的比例进行缩放 默认true preScale Number 改变像素到米的换算比例 默认1 Source: Map.js, line 201 Returns: obj -物体mesh Type Object addGround() 添加默认地面 Source: Map.js, line 213 remove(obj) 移除物体mesh Parameters: Name Type Description obj Object mesh Source: Map.js, line 233 setupDefaultLights() 设置默认光源 Source: Map.js, line 240 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
